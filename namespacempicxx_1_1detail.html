<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>mpicxx: mpicxx::detail Namespace Reference</title>
        <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link type="image/x-icon" rel="shortcut icon" href="logo.ico">
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link type="text/css" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab">
        <link type="text/css" rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
        <link type="text/css" rel="stylesheet" href="doxygen.css">
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
    <div id="page-container">
    <div id="content-wrap">
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <img class="navbar-logo" src=logo.png>
                    <div class="navbar-brand" style="color: #ddd; display: inline-block; vertical-align: middle;">mpicxx - A header only C++ wrapper library for MPI (v0.4.0)</div>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempicxx.html">mpicxx</a></li><li class="navelem"><a class="el" href="namespacempicxx_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpicxx::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace is for implementation details and <b>should not</b> be used directly be users.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacempicxx_1_1detail_1_1adl__helper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail_1_1adl__helper.html">adl_helper</a></td></tr>
<tr class="memdesc:namespacempicxx_1_1detail_1_1adl__helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains ADL (argument dependent lookup) helpers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1detail_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents information of a specific source code location.  <a href="classmpicxx_1_1detail_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39a4c0521d637a6f82e7ed553b24d999"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a39a4c0521d637a6f82e7ed553b24d999">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a> category)</td></tr>
<tr class="memdesc:a39a4c0521d637a6f82e7ed553b24d999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream-insertion operator overload for the <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">mpicxx::detail::assertion_category</a> enum class.  <a href="#a39a4c0521d637a6f82e7ed553b24d999">More...</a><br /></td></tr>
<tr class="separator:a39a4c0521d637a6f82e7ed553b24d999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae731a3a48e508e8b3bf7d9a7882f3e75"><td class="memItemLeft" align="right" valign="top">fmt::text_style&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#ae731a3a48e508e8b3bf7d9a7882f3e75">assertion_category_color</a> (const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a> category)</td></tr>
<tr class="memdesc:ae731a3a48e508e8b3bf7d9a7882f3e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the color associated to the given assertion <code>category</code>.  <a href="#ae731a3a48e508e8b3bf7d9a7882f3e75">More...</a><br /></td></tr>
<tr class="separator:ae731a3a48e508e8b3bf7d9a7882f3e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9890f769b3462efe3fc42468ce578f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7b9890f769b3462efe3fc42468ce578f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a7b9890f769b3462efe3fc42468ce578f">check</a> (const bool cond, const char *cond_str, const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a> category, const <a class="el" href="classmpicxx_1_1detail_1_1source__location.html">source_location</a> &amp;loc, const char *msg, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7b9890f769b3462efe3fc42468ce578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets called by the <code>MPICXX_ASSERT_...</code> macros and does the actual assertion checking.  <a href="#a7b9890f769b3462efe3fc42468ce578f">More...</a><br /></td></tr>
<tr class="separator:a7b9890f769b3462efe3fc42468ce578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">conversion functions to std::string</div></td></tr>
<tr class="memitem:af8b88976e007657a2a5669f38de553e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8b88976e007657a2a5669f38de553e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#af8b88976e007657a2a5669f38de553e7">convert_to_string</a> (T &amp;&amp;arg)</td></tr>
<tr class="memdesc:af8b88976e007657a2a5669f38de553e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to convert the given <code>arg</code> to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>.  <a href="#af8b88976e007657a2a5669f38de553e7">More...</a><br /></td></tr>
<tr class="separator:af8b88976e007657a2a5669f38de553e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">conversion functions</div></td></tr>
<tr class="memitem:aa7f5c89381eab2ddb8306ffdae43f078"><td class="memTemplParams" colspan="2">template&lt;is_string T&gt; </td></tr>
<tr class="memitem:aa7f5c89381eab2ddb8306ffdae43f078"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#aa7f5c89381eab2ddb8306ffdae43f078">convert_to_char_pointer</a> (const T &amp;str) noexcept</td></tr>
<tr class="memdesc:aa7f5c89381eab2ddb8306ffdae43f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the string <code>str</code>.  <a href="#aa7f5c89381eab2ddb8306ffdae43f078">More...</a><br /></td></tr>
<tr class="separator:aa7f5c89381eab2ddb8306ffdae43f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2fb8a4279c2dfa3f1689df9817f14"><td class="memTemplParams" colspan="2">template&lt;is_string T&gt; </td></tr>
<tr class="memitem:a3ef2fb8a4279c2dfa3f1689df9817f14"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a3ef2fb8a4279c2dfa3f1689df9817f14">convert_to_string_size</a> (const T &amp;str, [[maybe_unused]] const std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:a3ef2fb8a4279c2dfa3f1689df9817f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the string <code>str</code>.  <a href="#a3ef2fb8a4279c2dfa3f1689df9817f14">More...</a><br /></td></tr>
<tr class="separator:a3ef2fb8a4279c2dfa3f1689df9817f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">utility functions checking if all values in a parameter pack fulfill a predicate</div></td></tr>
<tr class="memitem:afca71dc39e8b9748b2cbacbf5b043548"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp , typename T , typename U &gt; </td></tr>
<tr class="memitem:afca71dc39e8b9748b2cbacbf5b043548"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#afca71dc39e8b9748b2cbacbf5b043548">all_same</a> (BinaryOp pred, const T &amp;t, const U &amp;u) noexcept(std::is_nothrow_invocable_r_v&lt; bool, BinaryOp, T, U &gt;) requires std</td></tr>
<tr class="memdesc:afca71dc39e8b9748b2cbacbf5b043548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether invoking the predicate <code>pred</code> with <code>t</code> and <code>u</code> evaluates to <code>true</code>.  <a href="#afca71dc39e8b9748b2cbacbf5b043548">More...</a><br /></td></tr>
<tr class="separator:afca71dc39e8b9748b2cbacbf5b043548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4db6df7e0b3e38d37ca0c159a884e1"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp , typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a3a4db6df7e0b3e38d37ca0c159a884e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a3a4db6df7e0b3e38d37ca0c159a884e1">all_same</a> (BinaryOp pred, const T &amp;t, const U &amp;u, const Args &amp;...args) noexcept(std::is_nothrow_invocable_r_v&lt; bool, BinaryOp, T, U &gt;) requires std</td></tr>
<tr class="memdesc:a3a4db6df7e0b3e38d37ca0c159a884e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the results of invoking the predicate <code>pred</code> with all parameters (<code>t</code>, <code>u</code> and <code>args</code>) compare equal.  <a href="#a3a4db6df7e0b3e38d37ca0c159a884e1">More...</a><br /></td></tr>
<tr class="separator:a3a4db6df7e0b3e38d37ca0c159a884e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989572ba045414117b1c874a001cc2c"><td class="memTemplParams" colspan="2">template&lt;typename UnaryOp , typename T , typename U &gt; </td></tr>
<tr class="memitem:ac989572ba045414117b1c874a001cc2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#ac989572ba045414117b1c874a001cc2c">all_same</a> (UnaryOp pred, const T &amp;t, const U &amp;u) noexcept(std::is_nothrow_invocable_v&lt; UnaryOp, T &gt; &amp;&amp;std::is_nothrow_invocable_v&lt; UnaryOp, U &gt;)</td></tr>
<tr class="memdesc:ac989572ba045414117b1c874a001cc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the results of invoking the predicate <code>pred</code> with <code>t</code> and <code>u</code> compare equal.  <a href="#ac989572ba045414117b1c874a001cc2c">More...</a><br /></td></tr>
<tr class="separator:ac989572ba045414117b1c874a001cc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3717c4e5ed10cf4c73fa7457b2b418"><td class="memTemplParams" colspan="2">template&lt;typename UnaryOp , typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a0b3717c4e5ed10cf4c73fa7457b2b418"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a0b3717c4e5ed10cf4c73fa7457b2b418">all_same</a> (UnaryOp pred, const T &amp;t, const U &amp;u, const Args &amp;...args) noexcept(std::is_nothrow_invocable_v&lt; UnaryOp, T &gt; &amp;&amp;std::is_nothrow_invocable_v&lt; UnaryOp, U &gt;)</td></tr>
<tr class="memdesc:a0b3717c4e5ed10cf4c73fa7457b2b418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the results of invoking the predicate <code>pred</code> with all parameters (<code>t</code>, <code>u</code> and <code>args</code>) compare equal.  <a href="#a0b3717c4e5ed10cf4c73fa7457b2b418">More...</a><br /></td></tr>
<tr class="separator:a0b3717c4e5ed10cf4c73fa7457b2b418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25011ab9fd5f3a6cb0113061e9c1a81"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename T &gt; </td></tr>
<tr class="memitem:ab25011ab9fd5f3a6cb0113061e9c1a81"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#ab25011ab9fd5f3a6cb0113061e9c1a81">all_same</a> (Op pred, const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ab25011ab9fd5f3a6cb0113061e9c1a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether all results of invoking <code>pred</code> compare equal. Since only one parameter is given, this function returns always <code>true</code>.  <a href="#ab25011ab9fd5f3a6cb0113061e9c1a81">More...</a><br /></td></tr>
<tr class="separator:ab25011ab9fd5f3a6cb0113061e9c1a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">custom, internally used, C++20 concepts</div></td></tr>
<tr class="memitem:ac868ceb9222d55ab6a6cdfd549811837"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac868ceb9222d55ab6a6cdfd549811837"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">is_string</a> = std::is_constructible_v&lt;std::string, T&gt;</td></tr>
<tr class="memdesc:ac868ceb9222d55ab6a6cdfd549811837"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">is_string&lt;T&gt;</a> </span> Concept that describes every <em>string</em> like type, i.e. <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string_view"><code>std::string_view</code></a>, <code>const char*</code> and <code>char[]</code>.  <a href="#ac868ceb9222d55ab6a6cdfd549811837">More...</a><br /></td></tr>
<tr class="separator:ac868ceb9222d55ab6a6cdfd549811837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37c0c21ccdc7c98535fc0f52964a057"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af37c0c21ccdc7c98535fc0f52964a057"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#af37c0c21ccdc7c98535fc0f52964a057">is_c_string</a> = std::is_same_v&lt;std::decay_t&lt;T&gt;, const char*&gt; || std::is_same_v&lt;std::decay_t&lt;T&gt;, char*&gt;</td></tr>
<tr class="memdesc:af37c0c21ccdc7c98535fc0f52964a057"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#af37c0c21ccdc7c98535fc0f52964a057">is_c_string&lt;T&gt;</a> </span> Concept that describes a c-style string, i.e. <code>const char*</code>, <code>char*</code>, <code>const char[]</code> and <code>char[]</code>.  <a href="#af37c0c21ccdc7c98535fc0f52964a057">More...</a><br /></td></tr>
<tr class="separator:af37c0c21ccdc7c98535fc0f52964a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcce7194790ae4bb2055ec77ba9da602"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:afcce7194790ae4bb2055ec77ba9da602"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#afcce7194790ae4bb2055ec77ba9da602">is_main_pointer</a> = std::is_invocable_r_v&lt;int, T, Args...&gt;</td></tr>
<tr class="memdesc:afcce7194790ae4bb2055ec77ba9da602"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#afcce7194790ae4bb2055ec77ba9da602">is_main_pointer&lt;T, Args...&gt;</a> </span> Concept that describes a function that accepts any number of parameters (including none) and returns an <code>int</code>.  <a href="#afcce7194790ae4bb2055ec77ba9da602">More...</a><br /></td></tr>
<tr class="separator:afcce7194790ae4bb2055ec77ba9da602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3947fd432dae099daabded1bd4f3f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aec3947fd432dae099daabded1bd4f3f0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#aec3947fd432dae099daabded1bd4f3f0">is_main_args_pointer</a> = std::is_invocable_r_v&lt;int, T, int, char**, Args...&gt;</td></tr>
<tr class="memdesc:aec3947fd432dae099daabded1bd4f3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aec3947fd432dae099daabded1bd4f3f0">is_main_args_pointer&lt;T, Args...&gt;</a> </span> Concept that describes a function that does accept an <code>int</code>, an array of c-style strings and any number of additional parameters (including none) and returns an <code>int</code>.  <a href="#aec3947fd432dae099daabded1bd4f3f0">More...</a><br /></td></tr>
<tr class="separator:aec3947fd432dae099daabded1bd4f3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa2de298220e8cb4c28699796c5563"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6fa2de298220e8cb4c28699796c5563"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">is_pair</a></td></tr>
<tr class="memdesc:aa6fa2de298220e8cb4c28699796c5563"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">is_pair&lt;T&gt;</a> </span> Concept that describes a <a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> like type.  <a href="#aa6fa2de298220e8cb4c28699796c5563">More...</a><br /></td></tr>
<tr class="separator:aa6fa2de298220e8cb4c28699796c5563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a5321a2cd2191bface50a109c461d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea1a5321a2cd2191bface50a109c461d"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#aea1a5321a2cd2191bface50a109c461d">is_spawner</a></td></tr>
<tr class="memdesc:aea1a5321a2cd2191bface50a109c461d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aea1a5321a2cd2191bface50a109c461d">is_spawner&lt;T&gt;</a> </span> Concept that describes a spawner class, i.e. either <a class="el" href="classmpicxx_1_1single__spawner.html">mpicxx::single_spawner</a> or <a class="el" href="classmpicxx_1_1multiple__spawner.html">mpicxx::multiple_spawner</a>.  <a href="#aea1a5321a2cd2191bface50a109c461d">More...</a><br /></td></tr>
<tr class="separator:aea1a5321a2cd2191bface50a109c461d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43e87d642f256e6a024b0fbdc598779"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae43e87d642f256e6a024b0fbdc598779"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#ae43e87d642f256e6a024b0fbdc598779">is_info</a> = std::is_same_v&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a>&gt;</td></tr>
<tr class="memdesc:ae43e87d642f256e6a024b0fbdc598779"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#ae43e87d642f256e6a024b0fbdc598779">is_info&lt;T&gt;</a> </span> Concept that describes the <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> class.  <a href="#ae43e87d642f256e6a024b0fbdc598779">More...</a><br /></td></tr>
<tr class="separator:ae43e87d642f256e6a024b0fbdc598779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5941e62e25984c601df09b40ee6d9490"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5941e62e25984c601df09b40ee6d9490"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#a5941e62e25984c601df09b40ee6d9490">has_to_string</a> = requires (T t) { std::to_string(t); } || requires (T t) { <a class="el" href="namespacempicxx.html#ad5059762ddb1053c96d5c6a6eae84ebb">to_string</a>(t); }</td></tr>
<tr class="memdesc:a5941e62e25984c601df09b40ee6d9490"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#a5941e62e25984c601df09b40ee6d9490">has_to_string&lt;T&gt;</a> </span> Concept that describes a type that can be converted to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> using the <a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string"><code>to_string</code></a> function.  <a href="#a5941e62e25984c601df09b40ee6d9490">More...</a><br /></td></tr>
<tr class="separator:a5941e62e25984c601df09b40ee6d9490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa530b4e027776e521ba2c874a8ac24f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa530b4e027776e521ba2c874a8ac24f1"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempicxx_1_1detail.html#aa530b4e027776e521ba2c874a8ac24f1">has_ostringstream</a> = requires (T t) { std::declval&lt;std::ostringstream&gt;() &lt;&lt; t; }</td></tr>
<tr class="memdesc:aa530b4e027776e521ba2c874a8ac24f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aa530b4e027776e521ba2c874a8ac24f1">has_ostringstream&lt;T&gt;</a> </span> Concept that describes a type that can be converted to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> using the <a href="https://en.cppreference.com/w/cpp/language/operators"><code>operator&lt;&lt;</code></a> overload.  <a href="#aa530b4e027776e521ba2c874a8ac24f1">More...</a><br /></td></tr>
<tr class="separator:aa530b4e027776e521ba2c874a8ac24f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is for implementation details and <b>should not</b> be used directly be users. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a4e59c7413c5bd33a255d6d6916990a84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">mpicxx::detail::assertion_category</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for the different assertion categories. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4e59c7413c5bd33a255d6d6916990a84ac3c270a815f2c6329cf95844e757cf7f"></a>precondition&#160;</td><td class="fielddoc">
<p>precondition assertion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4e59c7413c5bd33a255d6d6916990a84a0f65662486e1019b8d968987da67a27d"></a>sanity&#160;</td><td class="fielddoc">
<p>sanity assertion </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a39a4c0521d637a6f82e7ed553b24d999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mpicxx::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a>&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream-insertion operator overload for the <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">mpicxx::detail::assertion_category</a> enum class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>an output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">category</td><td>the enum class value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a class="anchor" id="ae731a3a48e508e8b3bf7d9a7882f3e75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fmt::text_style mpicxx::detail::assertion_category_color </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a>&#160;</td>
          <td class="paramname"><em>category</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the color associated to the given assertion <code>category</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>the assertion category </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated color <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b9890f769b3462efe3fc42468ce578f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::detail::check </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cond_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">assertion_category</a>&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpicxx_1_1detail_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function gets called by the <code>MPICXX_ASSERT_...</code> macros and does the actual assertion checking. </p>
<p>If the assert condition <code>cond</code> evaluates to <code>false</code>, the condition, location, custom message and an optional stack trace are printed on the <a href="https://en.cppreference.com/w/cpp/io/c/std_streams"><code>stderr stream</code></a>. Afterwards the programs terminates with a call to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node225.htm"><em>MPI_Abort</em></a> or <a href="https://en.cppreference.com/w/cpp/utility/program/abort"><code>std::abort</code></a> respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>parameter pack for the placeholder types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>the assert condition, aborts the program if evaluates to <code>false</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond_str</td><td>the assert condition as string for a better assert message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">category</td><td>the <a class="el" href="namespacempicxx_1_1detail.html#a4e59c7413c5bd33a255d6d6916990a84">mpicxx::detail::assertion_category</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>the <a class="el" href="classmpicxx_1_1detail_1_1source__location.html">mpicxx::detail::source_location</a> where the assertion appeared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>the custom message printed after the assertion location (using the <a href="https://github.com/fmtlib/fmt">{fmt}</a> syntax) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the arguments used to fill the <a href="https://github.com/fmtlib/fmt">{fmt}</a> placeholders in the custom message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Abort(MPI_Comm comm, <span class="keywordtype">int</span> errorcode);    <span class="comment">// at most once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="af8b88976e007657a2a5669f38de553e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpicxx::detail::convert_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to convert the given <code>arg</code> to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>. </p>
<p>Tries to use the following ways to convert <code>arg</code> (in this order):</p><ol type="1">
<li>If T is a <code>bool</code>, returns either <code>std::string("true")</code> or <code>std::string("false")</code>.</li>
<li>If T is a <code>char</code>, returns <code>std::string(1, arg)</code></li>
<li>If T meets the <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">mpicxx::detail::is_string</a> requirements, returns <code>std::string(std::forward&lt;T&gt;(arg))</code>.</li>
<li>T can be converted using a <a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string"><code>to_string</code></a> function.</li>
<li>T can be converted using a <a href="https://en.cppreference.com/w/cpp/language/operators"><code>operator&lt;&lt;</code></a> overload.</li>
</ol>
<p>If <code>arg</code> can't be convert using one of this ways, a compiler error is issued. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> representation of <code>arg</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="aa7f5c89381eab2ddb8306ffdae43f078"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;is_string T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mpicxx::detail::convert_to_char_pointer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the string <code>str</code>. </p>
<p>If <code>str</code> is a pointer type, returns <code>str</code>, otherwise calls <a href="https://en.cppreference.com/w/cpp/iterator/data"><code>std::data</code></a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meet the <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">mpicxx::detail::is_string</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to get the pointer to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to <code>str</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ef2fb8a4279c2dfa3f1689df9817f14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;is_string T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t mpicxx::detail::convert_to_string_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the string <code>str</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meet the <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">mpicxx::detail::is_string</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to get the size from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of <code>str</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="afca71dc39e8b9748b2cbacbf5b043548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryOp , typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpicxx::detail::all_same </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether invoking the predicate <code>pred</code> with <code>t</code> and <code>u</code> evaluates to <code>true</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>a binary function (returning a <code>bool</code>) </td></tr>
    <tr><td class="paramname">T</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">U</td><td>an arbitrary type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>the binary function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>pred(t, u)</code> evaluates to <code>true</code>, otherwise <code>false</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a4db6df7e0b3e38d37ca0c159a884e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryOp , typename T , typename U , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpicxx::detail::all_same </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the results of invoking the predicate <code>pred</code> with all parameters (<code>t</code>, <code>u</code> and <code>args</code>) compare equal. </p>
<p>Evaluates: <code>pred(a, b) == pred(b, c) == ... == pred(y, z)</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>a binary function (returning a <code>bool</code>) </td></tr>
    <tr><td class="paramname">T</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">U</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">Args</td><td>a parameter pack of arbitrary types and size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>the binary function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>remaining arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all results compare equal, <code>false</code> otherwise <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="ac989572ba045414117b1c874a001cc2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryOp , typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpicxx::detail::all_same </td>
          <td>(</td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the results of invoking the predicate <code>pred</code> with <code>t</code> and <code>u</code> compare equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryOp</td><td>an unary function </td></tr>
    <tr><td class="paramname">T</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">U</td><td>an arbitrary type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>the unary function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>pred(t) == pred(u)</code>, otherwise <code>false</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a0b3717c4e5ed10cf4c73fa7457b2b418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryOp , typename T , typename U , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpicxx::detail::all_same </td>
          <td>(</td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the results of invoking the predicate <code>pred</code> with all parameters (<code>t</code>, <code>u</code> and <code>args</code>) compare equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryOp</td><td>an unary function </td></tr>
    <tr><td class="paramname">T</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">U</td><td>an arbitrary type </td></tr>
    <tr><td class="paramname">Args</td><td>a parameter pack of arbitrary types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>the unary function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>remaining arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all results compare equal, otherwise <code>false</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="ab25011ab9fd5f3a6cb0113061e9c1a81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpicxx::detail::all_same </td>
          <td>(</td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether all results of invoking <code>pred</code> compare equal. Since only one parameter is given, this function returns always <code>true</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>a function predicate </td></tr>
    <tr><td class="paramname">T</td><td>the argument type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always <code>true</code> <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac868ceb9222d55ab6a6cdfd549811837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_string = std::is_constructible_v&lt;std::string, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">is_string&lt;T&gt;</a> </span> Concept that describes every <em>string</em> like type, i.e. <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string_view"><code>std::string_view</code></a>, <code>const char*</code> and <code>char[]</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af37c0c21ccdc7c98535fc0f52964a057"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_c_string = std::is_same_v&lt;std::decay_t&lt;T&gt;, const char*&gt; || std::is_same_v&lt;std::decay_t&lt;T&gt;, char*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#af37c0c21ccdc7c98535fc0f52964a057">is_c_string&lt;T&gt;</a> </span> Concept that describes a c-style string, i.e. <code>const char*</code>, <code>char*</code>, <code>const char[]</code> and <code>char[]</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcce7194790ae4bb2055ec77ba9da602"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_main_pointer = std::is_invocable_r_v&lt;int, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#afcce7194790ae4bb2055ec77ba9da602">is_main_pointer&lt;T, Args...&gt;</a> </span> Concept that describes a function that accepts any number of parameters (including none) and returns an <code>int</code>. </p>
<p>Such a function is <code>int <a class="el" href="namespacempicxx.html#ae0f4474ecfbb1bd9434d56f216592dd1" title="Correctly setup and teardown the MPI environment while executing the code given by func...">main()</a></code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a callable </td></tr>
    <tr><td class="paramname">Args</td><td>optional parameters (potentially empty) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec3947fd432dae099daabded1bd4f3f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_main_args_pointer = std::is_invocable_r_v&lt;int, T, int, char**, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aec3947fd432dae099daabded1bd4f3f0">is_main_args_pointer&lt;T, Args...&gt;</a> </span> Concept that describes a function that does accept an <code>int</code>, an array of c-style strings and any number of additional parameters (including none) and returns an <code>int</code>. </p>
<p>Such a function is <code>int main(int argc, char** argv)</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a callable </td></tr>
    <tr><td class="paramname">Args</td><td>optional parameters (potentially empty) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6fa2de298220e8cb4c28699796c5563"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_pair</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires (T p) {</div><div class="line">        { p.first }  -&gt; std::convertible_to&lt;typename std::remove_cvref_t&lt;T&gt;::first_type&gt;;</div><div class="line">        { p.second } -&gt; std::convertible_to&lt;typename std::remove_cvref_t&lt;T&gt;::second_type&gt;;</div><div class="line">    }</div></div><!-- fragment -->
<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">is_pair&lt;T&gt;</a> </span> Concept that describes a <a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> like type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea1a5321a2cd2191bface50a109c461d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_spawner</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::is_same_v&lt;std::remove_cvref_t&lt;T&gt;, <a class="code" href="classmpicxx_1_1single__spawner.html">mpicxx::single_spawner</a>&gt;</div><div class="line">                      || std::is_same_v&lt;std::remove_cvref_t&lt;T&gt;, <a class="code" href="classmpicxx_1_1multiple__spawner.html">mpicxx::multiple_spawner</a>&gt;</div><div class="ttc" id="classmpicxx_1_1single__spawner_html"><div class="ttname"><a href="classmpicxx_1_1single__spawner.html">mpicxx::single_spawner</a></div><div class="ttdoc">Spawner class which enables to spawn (multiple) MPI processes at runtime. </div><div class="ttdef"><b>Definition:</b> single_spawner.hpp:38</div></div>
<div class="ttc" id="classmpicxx_1_1multiple__spawner_html"><div class="ttname"><a href="classmpicxx_1_1multiple__spawner.html">mpicxx::multiple_spawner</a></div><div class="ttdoc">Spawner class which enables to spawn (multiple) different MPI processes at runtime. </div><div class="ttdef"><b>Definition:</b> multiple_spawner.hpp:42</div></div>
</div><!-- fragment -->
<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aea1a5321a2cd2191bface50a109c461d">is_spawner&lt;T&gt;</a> </span> Concept that describes a spawner class, i.e. either <a class="el" href="classmpicxx_1_1single__spawner.html">mpicxx::single_spawner</a> or <a class="el" href="classmpicxx_1_1multiple__spawner.html">mpicxx::multiple_spawner</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae43e87d642f256e6a024b0fbdc598779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::is_info = std::is_same_v&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#ae43e87d642f256e6a024b0fbdc598779">is_info&lt;T&gt;</a> </span> Concept that describes the <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5941e62e25984c601df09b40ee6d9490"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::has_to_string = requires (T t) { std::to_string(t); } || requires (T t) { <a class="el" href="namespacempicxx.html#ad5059762ddb1053c96d5c6a6eae84ebb">to_string</a>(t); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#a5941e62e25984c601df09b40ee6d9490">has_to_string&lt;T&gt;</a> </span> Concept that describes a type that can be converted to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> using the <a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string"><code>to_string</code></a> function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa530b4e027776e521ba2c874a8ac24f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept mpicxx::detail::has_ostringstream = requires (T t) { std::declval&lt;std::ostringstream&gt;() &lt;&lt; t; }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="concept">concept <a class="el" href="namespacempicxx_1_1detail.html#aa530b4e027776e521ba2c874a8ac24f1">has_ostringstream&lt;T&gt;</a> </span> Concept that describes a type that can be converted to a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> using the <a href="https://en.cppreference.com/w/cpp/language/operators"><code>operator&lt;&lt;</code></a> overload. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the compared to type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
</div>
<address class="footer">
  <div class="footer-container" style="color: #fff; font-size: 16px;">
    <span>Authored by Marcel Breyer</span>
    <a style="color: white; margin: 0 15%; text-decoration: none;" href="https://github.com/arkantos493/MPICXX">
      <i class="fa fa-github"><span style="font: 400 16px Roboto,sans-serif;"> GitHub</span></i>
    </a>
    <span class="theme-switch-wrapper">
      <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <span class="slider round"></span>
      </label>
      <em class="theme-switch-text">Enable Dark Mode!</em>
    </span>
  </div>
</address>
</div>
</body>
</html>
