<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>mpicxx: mpicxx::info Class Reference</title>
        <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link type="image/x-icon" rel="shortcut icon" href="logo.ico">
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link type="text/css" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab">
        <link type="text/css" rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
        <link type="text/css" rel="stylesheet" href="doxygen.css">
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
    <div id="page-container">
    <div id="content-wrap">
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <img class="navbar-logo" src=logo.png>
                    <div class="navbar-brand" style="color: #ddd; display: inline-block; vertical-align: middle;">mpicxx - A header only C++ wrapper library for MPI (v0.4.1)</div>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempicxx.html">mpicxx</a></li><li class="navelem"><a class="el" href="classmpicxx_1_1info.html">info</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmpicxx_1_1info-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpicxx::info Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is a wrapper to the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object providing a interface inspired by <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> and <a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a>.  
 <a href="classmpicxx_1_1info.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="info_8hpp_source.html">info.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">iterator_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides iterator and const_iterator for an info object.  <a href="classmpicxx_1_1info_1_1iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info_1_1proxy.html">proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for <a class="el" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">mpicxx::info::at(T&amp;&amp;)</a>, <a class="el" href="classmpicxx_1_1info.html#a898ab9a9f313dec15a1e137078fd83b6">mpicxx::info::at(const std::string_view) const</a> and <a class="el" href="classmpicxx_1_1info.html#add2673e15b1de1fa4506775cce1493f3">mpicxx::info::operator[](T&amp;&amp;)</a> to distinguish between read and write accesses.  <a href="classmpicxx_1_1info_1_1proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7f718f1397b8e80181a75d4a39baac25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">key_type</a> = std::string</td></tr>
<tr class="memdesc:a7f718f1397b8e80181a75d4a39baac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a key.  <a href="#a7f718f1397b8e80181a75d4a39baac25">More...</a><br /></td></tr>
<tr class="separator:a7f718f1397b8e80181a75d4a39baac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a86fb5242a07f81b96d50d5c7324c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mapped_type</a> = std::string</td></tr>
<tr class="memdesc:a22a86fb5242a07f81b96d50d5c7324c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a value associated with a key.  <a href="#a22a86fb5242a07f81b96d50d5c7324c1">More...</a><br /></td></tr>
<tr class="separator:a22a86fb5242a07f81b96d50d5c7324c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dde098f7e38710ea9ec945b379adf9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> = std::pair&lt; const <a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">key_type</a>, <a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mapped_type</a> &gt;</td></tr>
<tr class="memdesc:a14dde098f7e38710ea9ec945b379adf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a [key, value]-pair.  <a href="#a14dde098f7e38710ea9ec945b379adf9">More...</a><br /></td></tr>
<tr class="separator:a14dde098f7e38710ea9ec945b379adf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4543ace2800d0d270e0211df9f06a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:acbf4543ace2800d0d270e0211df9f06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type.  <a href="#acbf4543ace2800d0d270e0211df9f06a">More...</a><br /></td></tr>
<tr class="separator:acbf4543ace2800d0d270e0211df9f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7914283da84e322816409c78030b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aefb7914283da84e322816409c78030b7">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:aefb7914283da84e322816409c78030b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type.  <a href="#aefb7914283da84e322816409c78030b7">More...</a><br /></td></tr>
<tr class="separator:aefb7914283da84e322816409c78030b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d354da791cf0a9277fccef487a9ebe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aa1d354da791cf0a9277fccef487a9ebe">reference</a> = <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa1d354da791cf0a9277fccef487a9ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of value_type used as a reference.  <a href="#aa1d354da791cf0a9277fccef487a9ebe">More...</a><br /></td></tr>
<tr class="separator:aa1d354da791cf0a9277fccef487a9ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b07a4dcf2422c354505569ead813c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab08b07a4dcf2422c354505569ead813c">const_reference</a> = const <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &amp;</td></tr>
<tr class="memdesc:ab08b07a4dcf2422c354505569ead813c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of value_type used as a const reference.  <a href="#ab08b07a4dcf2422c354505569ead813c">More...</a><br /></td></tr>
<tr class="separator:ab08b07a4dcf2422c354505569ead813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf87f30784859c774fd07527c0d15203"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#acf87f30784859c774fd07527c0d15203">pointer</a> = <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> *</td></tr>
<tr class="memdesc:acf87f30784859c774fd07527c0d15203"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of value_type used as a pointer.  <a href="#acf87f30784859c774fd07527c0d15203">More...</a><br /></td></tr>
<tr class="separator:acf87f30784859c774fd07527c0d15203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74ae65736662705e207be36ea3de594"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ad74ae65736662705e207be36ea3de594">const_pointer</a> = const <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> *</td></tr>
<tr class="memdesc:ad74ae65736662705e207be36ea3de594"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of value_type used as a const pointer.  <a href="#ad74ae65736662705e207be36ea3de594">More...</a><br /></td></tr>
<tr class="separator:ad74ae65736662705e207be36ea3de594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abee20786bc8a05ae24f68048a5b150"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> = <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">iterator_impl</a>&lt; false &gt;</td></tr>
<tr class="memdesc:a4abee20786bc8a05ae24f68048a5b150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an iterator using the <code><a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html" title="Provides iterator and const_iterator for an info object. ">iterator_impl</a></code> template class with <code>is_const</code> set to <code>false</code>.  <a href="#a4abee20786bc8a05ae24f68048a5b150">More...</a><br /></td></tr>
<tr class="separator:a4abee20786bc8a05ae24f68048a5b150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f0ff12d58a477eb8d64ffad72c70b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> = <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">iterator_impl</a>&lt; true &gt;</td></tr>
<tr class="memdesc:abe8f0ff12d58a477eb8d64ffad72c70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a const_iterator using the <code><a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html" title="Provides iterator and const_iterator for an info object. ">iterator_impl</a></code> template class with <code>is_const</code> set to <code>true</code>.  <a href="#abe8f0ff12d58a477eb8d64ffad72c70b">More...</a><br /></td></tr>
<tr class="separator:abe8f0ff12d58a477eb8d64ffad72c70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254ece09352f3981826a299a04079ed1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> &gt;</td></tr>
<tr class="memdesc:a254ece09352f3981826a299a04079ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a reverse_iterator using <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator"><code>std::reverse_iterator</code></a>.  <a href="#a254ece09352f3981826a299a04079ed1">More...</a><br /></td></tr>
<tr class="separator:a254ece09352f3981826a299a04079ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3f8016e01aab7d3de0b99bf6deeaf6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:acb3f8016e01aab7d3de0b99bf6deeaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a const_reverse_iterator using <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator"><code>std::reverse_iterator</code></a>.  <a href="#acb3f8016e01aab7d3de0b99bf6deeaf6">More...</a><br /></td></tr>
<tr class="separator:acb3f8016e01aab7d3de0b99bf6deeaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2cb40e9e8a8dc51504dd7a697986a28e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classmpicxx_1_1info.html">info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a2cb40e9e8a8dc51504dd7a697986a28e">env</a> = <a class="el" href="classmpicxx_1_1info.html">info</a>(MPI_INFO_ENV, false)</td></tr>
<tr class="memdesc:a2cb40e9e8a8dc51504dd7a697986a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static member that holds all execution environment information defined in <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node225.htm"><em>MPI_INFO_ENV</em></a>.  <a href="#a2cb40e9e8a8dc51504dd7a697986a28e">More...</a><br /></td></tr>
<tr class="separator:a2cb40e9e8a8dc51504dd7a697986a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4a6623a8c390bc24a79f4d63ba7b42"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classmpicxx_1_1info.html">info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#acb4a6623a8c390bc24a79f4d63ba7b42">null</a> = <a class="el" href="classmpicxx_1_1info.html">info</a>(MPI_INFO_NULL, false)</td></tr>
<tr class="memdesc:acb4a6623a8c390bc24a79f4d63ba7b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static null object which is mainly used to explicitly indicate that <b>no</b> info is provided.  <a href="#acb4a6623a8c390bc24a79f4d63ba7b42">More...</a><br /></td></tr>
<tr class="separator:acb4a6623a8c390bc24a79f4d63ba7b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
constructors and destructor</h2></td></tr>
<tr class="memitem:a674b9633f608f0965bd0bc39f7672356"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a674b9633f608f0965bd0bc39f7672356">info</a> ()</td></tr>
<tr class="memdesc:a674b9633f608f0965bd0bc39f7672356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty info object.  <a href="#a674b9633f608f0965bd0bc39f7672356">More...</a><br /></td></tr>
<tr class="separator:a674b9633f608f0965bd0bc39f7672356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7217c7d099ee09d7303c9d1b304c33d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a7217c7d099ee09d7303c9d1b304c33d3">info</a> (const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;other)</td></tr>
<tr class="memdesc:a7217c7d099ee09d7303c9d1b304c33d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the info object with a copy of the contents of <code>other</code>.  <a href="#a7217c7d099ee09d7303c9d1b304c33d3">More...</a><br /></td></tr>
<tr class="separator:a7217c7d099ee09d7303c9d1b304c33d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2bc3a6d84eb4def7f363a77818e625"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a7d2bc3a6d84eb4def7f363a77818e625">info</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a7d2bc3a6d84eb4def7f363a77818e625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the info object with the contents of <code>other</code> using move semantics.  <a href="#a7d2bc3a6d84eb4def7f363a77818e625">More...</a><br /></td></tr>
<tr class="separator:a7d2bc3a6d84eb4def7f363a77818e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b1256fd156bee20e72def2c22a2365"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator InputIter&gt; </td></tr>
<tr class="memitem:ab7b1256fd156bee20e72def2c22a2365"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab7b1256fd156bee20e72def2c22a2365">info</a> (InputIter first, InputIter last)</td></tr>
<tr class="memdesc:ab7b1256fd156bee20e72def2c22a2365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the info object with the contents of the range [<code>first</code>, <code>last</code>).  <a href="#ab7b1256fd156bee20e72def2c22a2365">More...</a><br /></td></tr>
<tr class="separator:ab7b1256fd156bee20e72def2c22a2365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0899a6845db4c6a0521fa548d61702"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a2b0899a6845db4c6a0521fa548d61702">info</a> (std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt; <a class="el" href="namespacempicxx.html#a9359a0e055ccab58ea27f8c06ac136f1">init</a>)</td></tr>
<tr class="memdesc:a2b0899a6845db4c6a0521fa548d61702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the info object with the contents of the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>init</code>.  <a href="#a2b0899a6845db4c6a0521fa548d61702">More...</a><br /></td></tr>
<tr class="separator:a2b0899a6845db4c6a0521fa548d61702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566161e4d8a5547884d158f472214d7a"><td class="memTemplParams" colspan="2">template&lt;detail::is_pair... T&gt; </td></tr>
<tr class="memitem:a566161e4d8a5547884d158f472214d7a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a566161e4d8a5547884d158f472214d7a">info</a> (T &amp;&amp;...args) requires(sizeof...(T) &gt; 0)</td></tr>
<tr class="memdesc:a566161e4d8a5547884d158f472214d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the info object with the contents of the parameter pack <code>args</code>.  <a href="#a566161e4d8a5547884d158f472214d7a">More...</a><br /></td></tr>
<tr class="separator:a566161e4d8a5547884d158f472214d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1396fd807a3349a2cc0baab57d5ff3"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aca1396fd807a3349a2cc0baab57d5ff3">info</a> (MPI_Info other, const bool is_freeable) noexcept</td></tr>
<tr class="memdesc:aca1396fd807a3349a2cc0baab57d5ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object in an <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> object.  <a href="#aca1396fd807a3349a2cc0baab57d5ff3">More...</a><br /></td></tr>
<tr class="separator:aca1396fd807a3349a2cc0baab57d5ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c97e9dceb5e980bd6ed8571d245f18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#af6c97e9dceb5e980bd6ed8571d245f18">~info</a> ()</td></tr>
<tr class="memdesc:af6c97e9dceb5e980bd6ed8571d245f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the info object.  <a href="#af6c97e9dceb5e980bd6ed8571d245f18">More...</a><br /></td></tr>
<tr class="separator:af6c97e9dceb5e980bd6ed8571d245f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
assignment operators</h2></td></tr>
<tr class="memitem:ac655696a9c371d9d6795f434b385252e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ac655696a9c371d9d6795f434b385252e">operator=</a> (const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac655696a9c371d9d6795f434b385252e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <a href="#ac655696a9c371d9d6795f434b385252e">More...</a><br /></td></tr>
<tr class="separator:ac655696a9c371d9d6795f434b385252e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c172b3d18c1ff9ec673eb47a75e2fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a0c172b3d18c1ff9ec673eb47a75e2fc7">operator=</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a0c172b3d18c1ff9ec673eb47a75e2fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with contents of <code>other</code> using move semantics.  <a href="#a0c172b3d18c1ff9ec673eb47a75e2fc7">More...</a><br /></td></tr>
<tr class="separator:a0c172b3d18c1ff9ec673eb47a75e2fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3a7a92dad6af8d264609ed80e03cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ac0c3a7a92dad6af8d264609ed80e03cb">operator=</a> (std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ac0c3a7a92dad6af8d264609ed80e03cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code>.  <a href="#ac0c3a7a92dad6af8d264609ed80e03cb">More...</a><br /></td></tr>
<tr class="separator:ac0c3a7a92dad6af8d264609ed80e03cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
iterators</h2></td></tr>
<tr class="memitem:a5618b588d5175c53a74249f00f0bc192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a5618b588d5175c53a74249f00f0bc192">begin</a> ()</td></tr>
<tr class="memdesc:a5618b588d5175c53a74249f00f0bc192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the first [key, value]-pair of the info object.  <a href="#a5618b588d5175c53a74249f00f0bc192">More...</a><br /></td></tr>
<tr class="separator:a5618b588d5175c53a74249f00f0bc192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d17488a6a2173429df46897a2005f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">end</a> ()</td></tr>
<tr class="memdesc:a8d17488a6a2173429df46897a2005f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the element following the last [key, value]-pair of the info object.  <a href="#a8d17488a6a2173429df46897a2005f8d">More...</a><br /></td></tr>
<tr class="separator:a8d17488a6a2173429df46897a2005f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4fed28987b0bc4c70011ac235d882f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a5d4fed28987b0bc4c70011ac235d882f">begin</a> () const </td></tr>
<tr class="memdesc:a5d4fed28987b0bc4c70011ac235d882f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair of the info object.  <a href="#a5d4fed28987b0bc4c70011ac235d882f">More...</a><br /></td></tr>
<tr class="separator:a5d4fed28987b0bc4c70011ac235d882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e79e2ca1b10707af1e192424ea8cd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a9e79e2ca1b10707af1e192424ea8cd87">end</a> () const </td></tr>
<tr class="memdesc:a9e79e2ca1b10707af1e192424ea8cd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair of the info object.  <a href="#a9e79e2ca1b10707af1e192424ea8cd87">More...</a><br /></td></tr>
<tr class="separator:a9e79e2ca1b10707af1e192424ea8cd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe02eb6b8a22e7c7952e54671f4dd4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#affe02eb6b8a22e7c7952e54671f4dd4b">cbegin</a> () const </td></tr>
<tr class="memdesc:affe02eb6b8a22e7c7952e54671f4dd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair of the info object.  <a href="#affe02eb6b8a22e7c7952e54671f4dd4b">More...</a><br /></td></tr>
<tr class="separator:affe02eb6b8a22e7c7952e54671f4dd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7a9db3da917ca964c98caa3dd195e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#afd7a9db3da917ca964c98caa3dd195e3">cend</a> () const </td></tr>
<tr class="memdesc:afd7a9db3da917ca964c98caa3dd195e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair of the info object.  <a href="#afd7a9db3da917ca964c98caa3dd195e3">More...</a><br /></td></tr>
<tr class="separator:afd7a9db3da917ca964c98caa3dd195e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6760609ddf99ff1f04614e011bf4df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aa6760609ddf99ff1f04614e011bf4df3">rbegin</a> ()</td></tr>
<tr class="memdesc:aa6760609ddf99ff1f04614e011bf4df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the first [key, value]-pair of the reversed info object.  <a href="#aa6760609ddf99ff1f04614e011bf4df3">More...</a><br /></td></tr>
<tr class="separator:aa6760609ddf99ff1f04614e011bf4df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cbd7bb270347d67cdebd4d55cea5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a41cbd7bb270347d67cdebd4d55cea5f2">rend</a> ()</td></tr>
<tr class="memdesc:a41cbd7bb270347d67cdebd4d55cea5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object.  <a href="#a41cbd7bb270347d67cdebd4d55cea5f2">More...</a><br /></td></tr>
<tr class="separator:a41cbd7bb270347d67cdebd4d55cea5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2090404400cc115b0adb836c8b3f07eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a2090404400cc115b0adb836c8b3f07eb">rbegin</a> () const </td></tr>
<tr class="memdesc:a2090404400cc115b0adb836c8b3f07eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair of the reversed info object.  <a href="#a2090404400cc115b0adb836c8b3f07eb">More...</a><br /></td></tr>
<tr class="separator:a2090404400cc115b0adb836c8b3f07eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba241adf983bdde1ebcfaa96a70f78d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aba241adf983bdde1ebcfaa96a70f78d1">rend</a> () const </td></tr>
<tr class="memdesc:aba241adf983bdde1ebcfaa96a70f78d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object.  <a href="#aba241adf983bdde1ebcfaa96a70f78d1">More...</a><br /></td></tr>
<tr class="separator:aba241adf983bdde1ebcfaa96a70f78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d995ab22661e388de263711d3d38f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ad0d995ab22661e388de263711d3d38f5">crbegin</a> () const </td></tr>
<tr class="memdesc:ad0d995ab22661e388de263711d3d38f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair of the reversed info object.  <a href="#ad0d995ab22661e388de263711d3d38f5">More...</a><br /></td></tr>
<tr class="separator:ad0d995ab22661e388de263711d3d38f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210b4486bd8e67fb6b868d26d39bc38b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a210b4486bd8e67fb6b868d26d39bc38b">crend</a> () const </td></tr>
<tr class="memdesc:a210b4486bd8e67fb6b868d26d39bc38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object.  <a href="#a210b4486bd8e67fb6b868d26d39bc38b">More...</a><br /></td></tr>
<tr class="separator:a210b4486bd8e67fb6b868d26d39bc38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
capacity</h2></td></tr>
<tr class="memitem:a58daa3b8eb5c9934742797d09ce601de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a58daa3b8eb5c9934742797d09ce601de">empty</a> () const </td></tr>
<tr class="memdesc:a58daa3b8eb5c9934742797d09ce601de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the info object has no [key, value]-pairs, i.e. whether <code><a class="el" href="classmpicxx_1_1info.html#a5618b588d5175c53a74249f00f0bc192" title="Returns an mpicxx::info::iterator to the first [key, value]-pair of the info object. ">begin()</a> == <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d" title="Returns an mpicxx::info::iterator to the element following the last [key, value]-pair of the info obj...">end()</a></code>.  <a href="#a58daa3b8eb5c9934742797d09ce601de">More...</a><br /></td></tr>
<tr class="separator:a58daa3b8eb5c9934742797d09ce601de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c0052f50d435a94e639548e134e7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9">size</a> () const </td></tr>
<tr class="memdesc:a66c0052f50d435a94e639548e134e7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of [key, value]-pairs in the info object, i.e. <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(begin(), end())</code></a>.  <a href="#a66c0052f50d435a94e639548e134e7c9">More...</a><br /></td></tr>
<tr class="separator:a66c0052f50d435a94e639548e134e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3f84c6c6a0a0287ed285a4c117632f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aad3f84c6c6a0a0287ed285a4c117632f">max_size</a> ()</td></tr>
<tr class="memdesc:aad3f84c6c6a0a0287ed285a4c117632f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of [key, value]-pairs an info object is able to hold due to system or library implementation limitations, <br />
 i.e. <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(begin(), end())</code></a> for the largest info object.  <a href="#aad3f84c6c6a0a0287ed285a4c117632f">More...</a><br /></td></tr>
<tr class="separator:aad3f84c6c6a0a0287ed285a4c117632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
modifiers</h2></td></tr>
<tr class="memitem:ac7798c2d24be1ab8a3ef6eb4183234e1"><td class="memTemplParams" colspan="2">template&lt;detail::is_string T&gt; </td></tr>
<tr class="memitem:ac7798c2d24be1ab8a3ef6eb4183234e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info_1_1proxy.html">proxy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a> (T &amp;&amp;key)</td></tr>
<tr class="memdesc:ac7798c2d24be1ab8a3ef6eb4183234e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value associated with the given <code>key</code> including bounds checks.  <a href="#ac7798c2d24be1ab8a3ef6eb4183234e1">More...</a><br /></td></tr>
<tr class="separator:ac7798c2d24be1ab8a3ef6eb4183234e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898ab9a9f313dec15a1e137078fd83b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a898ab9a9f313dec15a1e137078fd83b6">at</a> (const std::string_view key) const </td></tr>
<tr class="memdesc:a898ab9a9f313dec15a1e137078fd83b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value associated with the given <code>key</code> including bounds checks.  <a href="#a898ab9a9f313dec15a1e137078fd83b6">More...</a><br /></td></tr>
<tr class="separator:a898ab9a9f313dec15a1e137078fd83b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2673e15b1de1fa4506775cce1493f3"><td class="memTemplParams" colspan="2">template&lt;detail::is_string T&gt; </td></tr>
<tr class="memitem:add2673e15b1de1fa4506775cce1493f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info_1_1proxy.html">proxy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#add2673e15b1de1fa4506775cce1493f3">operator[]</a> (T &amp;&amp;key)</td></tr>
<tr class="memdesc:add2673e15b1de1fa4506775cce1493f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value associated with the given <code>key</code>.  <a href="#add2673e15b1de1fa4506775cce1493f3">More...</a><br /></td></tr>
<tr class="separator:add2673e15b1de1fa4506775cce1493f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff62267cd204ac64ecda16907ebad22"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a6ff62267cd204ac64ecda16907ebad22">insert</a> (const std::string_view key, const std::string_view value)</td></tr>
<tr class="memdesc:a6ff62267cd204ac64ecda16907ebad22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given [key, value]-pair if the info object doesn't already contain a [key, value]-pair with an equivalent key.  <a href="#a6ff62267cd204ac64ecda16907ebad22">More...</a><br /></td></tr>
<tr class="separator:a6ff62267cd204ac64ecda16907ebad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2b444bb7b94d0f54c7c4d02c1e2df5"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator InputIt&gt; </td></tr>
<tr class="memitem:a9f2b444bb7b94d0f54c7c4d02c1e2df5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a9f2b444bb7b94d0f54c7c4d02c1e2df5">insert</a> (InputIt first, InputIt last) requires(!detail</td></tr>
<tr class="memdesc:a9f2b444bb7b94d0f54c7c4d02c1e2df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all [key, value]-pairs from the range [<code>first</code>, <code>last</code>) if the info object does not already contain a [key, value]-pair with an equivalent key.  <a href="#a9f2b444bb7b94d0f54c7c4d02c1e2df5">More...</a><br /></td></tr>
<tr class="separator:a9f2b444bb7b94d0f54c7c4d02c1e2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4436a93cbef1a6a01e0633b241082b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab4436a93cbef1a6a01e0633b241082b1">insert</a> (std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ab4436a93cbef1a6a01e0633b241082b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all [key, value]-pairs from the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code> if the info object does not already contain a [key, value]-pair with an equivalent key.  <a href="#ab4436a93cbef1a6a01e0633b241082b1">More...</a><br /></td></tr>
<tr class="separator:ab4436a93cbef1a6a01e0633b241082b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56346eb5afbe39c50b302372884e1e9"><td class="memTemplParams" colspan="2">template&lt;detail::is_pair... T&gt; </td></tr>
<tr class="memitem:ab56346eb5afbe39c50b302372884e1e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab56346eb5afbe39c50b302372884e1e9">insert</a> (T &amp;&amp;...args) requires(sizeof...(T) &gt; 0)</td></tr>
<tr class="memdesc:ab56346eb5afbe39c50b302372884e1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all [key, value]-pairs from the parameter pack <code>args</code> if the info object does not already contain a [key, value]-pair with an equivalent key.  <a href="#ab56346eb5afbe39c50b302372884e1e9">More...</a><br /></td></tr>
<tr class="separator:ab56346eb5afbe39c50b302372884e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3717b821521beeb4b9bec2003de080b2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a3717b821521beeb4b9bec2003de080b2">insert_or_assign</a> (const std::string_view key, const std::string_view value)</td></tr>
<tr class="memdesc:a3717b821521beeb4b9bec2003de080b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or assign the given [key, value]-pair to the info object.  <a href="#a3717b821521beeb4b9bec2003de080b2">More...</a><br /></td></tr>
<tr class="separator:a3717b821521beeb4b9bec2003de080b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4c14429bea8bc034fed7ab1c7128a"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator InputIt&gt; </td></tr>
<tr class="memitem:ac2c4c14429bea8bc034fed7ab1c7128a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ac2c4c14429bea8bc034fed7ab1c7128a">insert_or_assign</a> (InputIt first, InputIt last) requires(!detail</td></tr>
<tr class="memdesc:ac2c4c14429bea8bc034fed7ab1c7128a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or assigns [key, value]-pairs from range [<code>first</code>, <code>last</code>) to the info object.  <a href="#ac2c4c14429bea8bc034fed7ab1c7128a">More...</a><br /></td></tr>
<tr class="separator:ac2c4c14429bea8bc034fed7ab1c7128a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf832a5749c4664b5e55a239544eccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a6bf832a5749c4664b5e55a239544eccb">insert_or_assign</a> (std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a6bf832a5749c4664b5e55a239544eccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or assigns [key, value]-pairs from the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code> to the info object.  <a href="#a6bf832a5749c4664b5e55a239544eccb">More...</a><br /></td></tr>
<tr class="separator:a6bf832a5749c4664b5e55a239544eccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2839a18169b2445288146e0e89c20f8f"><td class="memTemplParams" colspan="2">template&lt;detail::is_pair... T&gt; </td></tr>
<tr class="memitem:a2839a18169b2445288146e0e89c20f8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a2839a18169b2445288146e0e89c20f8f">insert_or_assign</a> (T &amp;&amp;...args) requires(sizeof...(T) &gt; 0)</td></tr>
<tr class="memdesc:a2839a18169b2445288146e0e89c20f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or assigns [key, value]-pairs from the parameter pack <code>args</code> to the info object.  <a href="#a2839a18169b2445288146e0e89c20f8f">More...</a><br /></td></tr>
<tr class="separator:a2839a18169b2445288146e0e89c20f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c651d9b6fb1b923efc8118a625a3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a90c651d9b6fb1b923efc8118a625a3d8">clear</a> ()</td></tr>
<tr class="memdesc:a90c651d9b6fb1b923efc8118a625a3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all [key, value]-pairs from the info object.  <a href="#a90c651d9b6fb1b923efc8118a625a3d8">More...</a><br /></td></tr>
<tr class="separator:a90c651d9b6fb1b923efc8118a625a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5837d0f81c7dfba8a434209f69630dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a5837d0f81c7dfba8a434209f69630dc9">erase</a> (<a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a5837d0f81c7dfba8a434209f69630dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the [key, value]-pair at <code>pos</code>.  <a href="#a5837d0f81c7dfba8a434209f69630dc9">More...</a><br /></td></tr>
<tr class="separator:a5837d0f81c7dfba8a434209f69630dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d9b5c7cfde4bfbce27f64c6c3486cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ae5d9b5c7cfde4bfbce27f64c6c3486cb">erase</a> (<a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> first, <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> last)</td></tr>
<tr class="memdesc:ae5d9b5c7cfde4bfbce27f64c6c3486cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all [key, value]-pairs in the range [<code>first</code>, <code>last</code>).  <a href="#ae5d9b5c7cfde4bfbce27f64c6c3486cb">More...</a><br /></td></tr>
<tr class="separator:ae5d9b5c7cfde4bfbce27f64c6c3486cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a6a53da50db9d617e69221958aff96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a80a6a53da50db9d617e69221958aff96">erase</a> (const std::string_view key)</td></tr>
<tr class="memdesc:a80a6a53da50db9d617e69221958aff96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the [key, value]-pair (if one exists) with the key equivalent to <code>key</code>.  <a href="#a80a6a53da50db9d617e69221958aff96">More...</a><br /></td></tr>
<tr class="separator:a80a6a53da50db9d617e69221958aff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1c276b1173ea4d51586922ce64df1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a1c1c276b1173ea4d51586922ce64df1c">swap</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a1c1c276b1173ea4d51586922ce64df1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the info object with those of <code>other</code>.  <a href="#a1c1c276b1173ea4d51586922ce64df1c">More...</a><br /></td></tr>
<tr class="separator:a1c1c276b1173ea4d51586922ce64df1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d7dcd1a1c88b23a69172c7c19b6cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ac4d7dcd1a1c88b23a69172c7c19b6cec">extract</a> (<a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ac4d7dcd1a1c88b23a69172c7c19b6cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the [key, value]-pair at <code>pos</code> and returns it.  <a href="#ac4d7dcd1a1c88b23a69172c7c19b6cec">More...</a><br /></td></tr>
<tr class="separator:ac4d7dcd1a1c88b23a69172c7c19b6cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69594c2c6b82aceb39323149e8975e9d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a69594c2c6b82aceb39323149e8975e9d">extract</a> (const std::string_view key)</td></tr>
<tr class="memdesc:a69594c2c6b82aceb39323149e8975e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the [key, value]-pair (if one exists) with the key equivalent to <code>key</code> and returns the removed [key, value]-pair.  <a href="#a69594c2c6b82aceb39323149e8975e9d">More...</a><br /></td></tr>
<tr class="separator:a69594c2c6b82aceb39323149e8975e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0f5caa340db4c52ef9b913eb5246da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a2d0f5caa340db4c52ef9b913eb5246da">merge</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;source)</td></tr>
<tr class="memdesc:a2d0f5caa340db4c52ef9b913eb5246da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract each [key, value]-pair in <code>source</code> and insert it into <code>*this</code>.  <a href="#a2d0f5caa340db4c52ef9b913eb5246da">More...</a><br /></td></tr>
<tr class="separator:a2d0f5caa340db4c52ef9b913eb5246da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
lookup</h2></td></tr>
<tr class="memitem:af70ad2cab67e4691f7953a49bb2d31b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#af70ad2cab67e4691f7953a49bb2d31b0">count</a> (const std::string_view key) const </td></tr>
<tr class="memdesc:af70ad2cab67e4691f7953a49bb2d31b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of [key, value]-pairs with key equivalent to <code>key</code>.  <a href="#af70ad2cab67e4691f7953a49bb2d31b0">More...</a><br /></td></tr>
<tr class="separator:af70ad2cab67e4691f7953a49bb2d31b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9b4dca42989c5a9398e0de14735ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a9d9b4dca42989c5a9398e0de14735ec4">find</a> (const std::string_view key)</td></tr>
<tr class="memdesc:a9d9b4dca42989c5a9398e0de14735ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a [key, value]-pair with key equivalent to <code>key</code>.  <a href="#a9d9b4dca42989c5a9398e0de14735ec4">More...</a><br /></td></tr>
<tr class="separator:a9d9b4dca42989c5a9398e0de14735ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9429cd04a5c3cc3383255095821baccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a9429cd04a5c3cc3383255095821baccd">find</a> (const std::string_view key) const </td></tr>
<tr class="memdesc:a9429cd04a5c3cc3383255095821baccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a [key, value]-pair with key equivalent to <code>key</code>.  <a href="#a9429cd04a5c3cc3383255095821baccd">More...</a><br /></td></tr>
<tr class="separator:a9429cd04a5c3cc3383255095821baccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063ced9374c9b852eb12b04b9bac69bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a063ced9374c9b852eb12b04b9bac69bf">contains</a> (const std::string_view key) const </td></tr>
<tr class="memdesc:a063ced9374c9b852eb12b04b9bac69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a [key, value]-pair with key equivalent to <code>key</code>.  <a href="#a063ced9374c9b852eb12b04b9bac69bf">More...</a><br /></td></tr>
<tr class="separator:a063ced9374c9b852eb12b04b9bac69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6ec98bc2092e420e45a9677e859faf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a4e6ec98bc2092e420e45a9677e859faf">equal_range</a> (const std::string_view key)</td></tr>
<tr class="memdesc:a4e6ec98bc2092e420e45a9677e859faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all [key, value]-pairs with key equivalent to <code>key</code>.  <a href="#a4e6ec98bc2092e420e45a9677e859faf">More...</a><br /></td></tr>
<tr class="separator:a4e6ec98bc2092e420e45a9677e859faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa10599c33db63a356dfa82ff6ad628b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>, <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#afa10599c33db63a356dfa82ff6ad628b">equal_range</a> (const std::string_view key) const </td></tr>
<tr class="memdesc:afa10599c33db63a356dfa82ff6ad628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all [key, value]-pairs with key equivalent to <code>key</code>.  <a href="#afa10599c33db63a356dfa82ff6ad628b">More...</a><br /></td></tr>
<tr class="separator:afa10599c33db63a356dfa82ff6ad628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
non-member functions</h2></td></tr>
<tr class="memitem:a5c6d31526b4d271002d021f3e007843f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a5c6d31526b4d271002d021f3e007843f">operator==</a> (const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;lhs, const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5c6d31526b4d271002d021f3e007843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of the two info objects for equality.  <a href="#a5c6d31526b4d271002d021f3e007843f">More...</a><br /></td></tr>
<tr class="separator:a5c6d31526b4d271002d021f3e007843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada89b6e5e37c6af42c7ac81e0e460342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ada89b6e5e37c6af42c7ac81e0e460342">swap</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;lhs, <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ada89b6e5e37c6af42c7ac81e0e460342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a href="https://en.cppreference.com/w/cpp/algorithm/swap"><code>std::swap</code></a> algorithm for info objects. Swaps the contents of <code>lhs</code> and <code>rhs</code>.  <a href="#ada89b6e5e37c6af42c7ac81e0e460342">More...</a><br /></td></tr>
<tr class="separator:ada89b6e5e37c6af42c7ac81e0e460342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3857914e43179bf1e654071777d23fb9"><td class="memTemplParams" colspan="2">template&lt;typename Pred &gt; </td></tr>
<tr class="memitem:a3857914e43179bf1e654071777d23fb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a3857914e43179bf1e654071777d23fb9">erase_if</a> (<a class="el" href="classmpicxx_1_1info.html">info</a> &amp;c, Pred pred) requires std</td></tr>
<tr class="memdesc:a3857914e43179bf1e654071777d23fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all [key, value]-pairs that satisfy the predicate <code>pred</code> from the info object.  <a href="#a3857914e43179bf1e654071777d23fb9">More...</a><br /></td></tr>
<tr class="separator:a3857914e43179bf1e654071777d23fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
additional member functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp416126ac5b868f3a91117313b139137f"></a> (member functions which are not related to the <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> or <a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a> interface) </p>
</td></tr>
<tr class="memitem:a329a23981fb8b3b65ab50db4f93ac9f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">key_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a329a23981fb8b3b65ab50db4f93ac9f4">keys</a> () const </td></tr>
<tr class="memdesc:a329a23981fb8b3b65ab50db4f93ac9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> containing all keys of the info object.  <a href="#a329a23981fb8b3b65ab50db4f93ac9f4">More...</a><br /></td></tr>
<tr class="separator:a329a23981fb8b3b65ab50db4f93ac9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec497f4b47fb1f40fb3a14068ce394f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#aec497f4b47fb1f40fb3a14068ce394f7">values</a> () const </td></tr>
<tr class="memdesc:aec497f4b47fb1f40fb3a14068ce394f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> containing all values of the info object.  <a href="#aec497f4b47fb1f40fb3a14068ce394f7">More...</a><br /></td></tr>
<tr class="separator:aec497f4b47fb1f40fb3a14068ce394f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd0ffdd2fff80d77e323bb1eb62f0f"><td class="memItemLeft" align="right" valign="top">const MPI_Info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a32dd0ffdd2fff80d77e323bb1eb62f0f">get</a> () const  noexcept</td></tr>
<tr class="memdesc:a32dd0ffdd2fff80d77e323bb1eb62f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object.  <a href="#a32dd0ffdd2fff80d77e323bb1eb62f0f">More...</a><br /></td></tr>
<tr class="separator:a32dd0ffdd2fff80d77e323bb1eb62f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf529df856751661fd63439997712527"><td class="memItemLeft" align="right" valign="top">MPI_Info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#acf529df856751661fd63439997712527">get</a> () noexcept</td></tr>
<tr class="memdesc:acf529df856751661fd63439997712527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object.  <a href="#acf529df856751661fd63439997712527">More...</a><br /></td></tr>
<tr class="separator:acf529df856751661fd63439997712527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e292ac2fc0f18b3766085d5279e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab17e292ac2fc0f18b3766085d5279e41">freeable</a> () const  noexcept</td></tr>
<tr class="memdesc:ab17e292ac2fc0f18b3766085d5279e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object gets automatically freed upon destruction, i.e. the destructor calls <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a>.  <a href="#ab17e292ac2fc0f18b3766085d5279e41">More...</a><br /></td></tr>
<tr class="separator:ab17e292ac2fc0f18b3766085d5279e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f933af2841504301c7016d930789d94"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#a0f933af2841504301c7016d930789d94">max_key_size</a> ()</td></tr>
<tr class="memdesc:a0f933af2841504301c7016d930789d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible key size of any [key, value]-pair.  <a href="#a0f933af2841504301c7016d930789d94">More...</a><br /></td></tr>
<tr class="separator:a0f933af2841504301c7016d930789d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16ceb42130a329753d9d2fe328a795c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpicxx_1_1info.html#ab16ceb42130a329753d9d2fe328a795c">max_value_size</a> ()</td></tr>
<tr class="memdesc:ab16ceb42130a329753d9d2fe328a795c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible value size of any [key, value]-pair.  <a href="#ab16ceb42130a329753d9d2fe328a795c">More...</a><br /></td></tr>
<tr class="separator:ab16ceb42130a329753d9d2fe328a795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a wrapper to the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object providing a interface inspired by <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> and <a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a>. </p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="info_8hpp.html">mpicxx/info/info.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="namespacempicxx.html#ae0f4474ecfbb1bd9434d56f216592dd1">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    {</div><div class="line">        <span class="comment">// create new info object</span></div><div class="line">        <a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> <a class="code" href="classmpicxx_1_1info.html#a674b9633f608f0965bd0bc39f7672356">info</a> = {{ <span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span> }, { <span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span> }};</div><div class="line"></div><div class="line">        <span class="comment">// change value of a specific key</span></div><div class="line">        info[<span class="stringliteral">&quot;key1&quot;</span>] = <span class="stringliteral">&quot;value1_override&quot;</span>;</div><div class="line">        <span class="comment">// print value of a specific key</span></div><div class="line">        std::cout &lt;&lt; info[<span class="stringliteral">&quot;key2&quot;</span>] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// check info object if it contains a specific key</span></div><div class="line">        <span class="keywordflow">if</span> (info.<a class="code" href="classmpicxx_1_1info.html#a063ced9374c9b852eb12b04b9bac69bf">contains</a>(<span class="stringliteral">&quot;key1&quot;</span>)) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;key found!&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// copy info object and compare them</span></div><div class="line">        <a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> info_copy(info);</div><div class="line">        <span class="keywordflow">if</span> (info == info_copy) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;info objects are equal&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// remove first element from a info object</span></div><div class="line">        <span class="keyword">auto</span> it = info.<a class="code" href="classmpicxx_1_1info.html#a5837d0f81c7dfba8a434209f69630dc9">erase</a>(info.<a class="code" href="classmpicxx_1_1info.html#a5618b588d5175c53a74249f00f0bc192">begin</a>());</div><div class="line"></div><div class="line">        <span class="comment">// print all elements of the MPI_INFO_ENV object</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : <a class="code" href="classmpicxx_1_1info.html#a2cb40e9e8a8dc51504dd7a697986a28e">mpicxx::info::env</a>) {</div><div class="line">            std::cout &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7f718f1397b8e80181a75d4a39baac25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">mpicxx::info::key_type</a> =  std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a key. </p>

</div>
</div>
<a class="anchor" id="a22a86fb5242a07f81b96d50d5c7324c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mpicxx::info::mapped_type</a> =  std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a value associated with a key. </p>

</div>
</div>
<a class="anchor" id="a14dde098f7e38710ea9ec945b379adf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">mpicxx::info::value_type</a> =  std::pair&lt;const <a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">key_type</a>, <a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mapped_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a [key, value]-pair. </p>

</div>
</div>
<a class="anchor" id="acbf4543ace2800d0d270e0211df9f06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">mpicxx::info::size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type. </p>

</div>
</div>
<a class="anchor" id="aefb7914283da84e322816409c78030b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#aefb7914283da84e322816409c78030b7">mpicxx::info::difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type. </p>

</div>
</div>
<a class="anchor" id="aa1d354da791cf0a9277fccef487a9ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#aa1d354da791cf0a9277fccef487a9ebe">mpicxx::info::reference</a> =  <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of value_type used as a reference. </p>

</div>
</div>
<a class="anchor" id="ab08b07a4dcf2422c354505569ead813c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#ab08b07a4dcf2422c354505569ead813c">mpicxx::info::const_reference</a> =  const <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of value_type used as a const reference. </p>

</div>
</div>
<a class="anchor" id="acf87f30784859c774fd07527c0d15203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#acf87f30784859c774fd07527c0d15203">mpicxx::info::pointer</a> =  <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of value_type used as a pointer. </p>

</div>
</div>
<a class="anchor" id="ad74ae65736662705e207be36ea3de594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#ad74ae65736662705e207be36ea3de594">mpicxx::info::const_pointer</a> =  const <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of value_type used as a const pointer. </p>

</div>
</div>
<a class="anchor" id="a4abee20786bc8a05ae24f68048a5b150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> =  <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">iterator_impl</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an iterator using the <code><a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html" title="Provides iterator and const_iterator for an info object. ">iterator_impl</a></code> template class with <code>is_const</code> set to <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="abe8f0ff12d58a477eb8d64ffad72c70b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> =  <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">iterator_impl</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a const_iterator using the <code><a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html" title="Provides iterator and const_iterator for an info object. ">iterator_impl</a></code> template class with <code>is_const</code> set to <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a254ece09352f3981826a299a04079ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a reverse_iterator using <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator"><code>std::reverse_iterator</code></a>. </p>

</div>
</div>
<a class="anchor" id="acb3f8016e01aab7d3de0b99bf6deeaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a const_reverse_iterator using <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator"><code>std::reverse_iterator</code></a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a674b9633f608f0965bd0bc39f7672356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty info object. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state.</dd></dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_create(MPI_Info *info);    <span class="comment">// exactly once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a7217c7d099ee09d7303c9d1b304c33d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the info object with a copy of the contents of <code>other</code>. </p>
<p>Retains <code>other's</code> [key, value]-pair ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>another info object to be used as source to initialize the [key, value]-pairs of this info object with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state iff <code>other</code> is in a valid state. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Every copied info object (except if <code>other.get() == MPI_INFO_NULL</code>) is marked <b>freeable</b> independent of the <b>freeable</b> state of make the copied-from info object.</dd></dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_dup(MPI_info info, MPI_info *newinfo);    <span class="comment">// at most once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d2bc3a6d84eb4def7f363a77818e625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the info object with the contents of <code>other</code> using move semantics. </p>
<p>Retains <code>other's</code> [key, value]-pair ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>another info object to be used as source to initialize the [key, value]-pairs of this info object with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state iff <code>other</code> is in a valid state. </dd>
<dd>
<code>other</code> is in the moved-from state, i.e. it refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All iterators referring to <code>other</code> remain valid, but now refer to <code>*this</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only a limited number of member functions can be called on an info object referring to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> (aka moved-from state):<ul>
<li>the destructor <a class="el" href="classmpicxx_1_1info.html#af6c97e9dceb5e980bd6ed8571d245f18" title="Destructs the info object. ">~info()</a></li>
<li>all assignment operators: <a class="el" href="classmpicxx_1_1info.html#ac655696a9c371d9d6795f434b385252e">mpicxx::info::operator=(const mpicxx::info&amp;)</a>, <a class="el" href="classmpicxx_1_1info.html#a0c172b3d18c1ff9ec673eb47a75e2fc7">mpicxx::info::operator=(mpicxx::info&amp;&amp;)</a> and <a class="el" href="classmpicxx_1_1info.html#ac0c3a7a92dad6af8d264609ed80e03cb">mpicxx::info::operator=(std::initializer_list&lt;value_type&gt;)</a></li>
<li>the swap member function: <a class="el" href="classmpicxx_1_1info.html#a1c1c276b1173ea4d51586922ce64df1c">mpicxx::info::swap(mpicxx::info&amp;)</a></li>
<li>the relational operators: <a class="el" href="classmpicxx_1_1info.html#a5c6d31526b4d271002d021f3e007843f">mpicxx::info::operator==(const mpicxx::info&amp;, const mpicxx::info&amp;)</a> and mpicxx::info::operator!=(const mpicxx::info&amp;, const mpicxx::info&amp;)</li>
<li>all static member functions: <a class="el" href="classmpicxx_1_1info.html#aad3f84c6c6a0a0287ed285a4c117632f">mpicxx::info::max_size()</a>, <a class="el" href="classmpicxx_1_1info.html#a0f933af2841504301c7016d930789d94">mpicxx::info::max_key_size()</a> and <a class="el" href="classmpicxx_1_1info.html#ab16ceb42130a329753d9d2fe328a795c">mpicxx::info::max_value_size()</a></li>
<li>all getters: <a class="el" href="classmpicxx_1_1info.html#acf529df856751661fd63439997712527">mpicxx::info::get()</a>, <a class="el" href="classmpicxx_1_1info.html#a32dd0ffdd2fff80d77e323bb1eb62f0f">mpicxx::info::get() const</a> and <a class="el" href="classmpicxx_1_1info.html#ab17e292ac2fc0f18b3766085d5279e41">mpicxx::info::freeable() const</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab7b1256fd156bee20e72def2c22a2365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::input_iterator InputIter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the info object with the contents of the range [<code>first</code>, <code>last</code>). </p>
<p>If multiple [key, value]-pairs in the range share the same key, the <b>last</b> occurrence determines the final value.</p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;const std::string, std::string&gt;&gt; key_value_pairs;</div><div class="line">key_value_pairs.emplace_back(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div><div class="line">key_value_pairs.emplace_back(<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>);</div><div class="line">key_value_pairs.emplace_back(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1_override&quot;</span>);</div><div class="line">key_value_pairs.emplace_back(<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> obj(key_value_pairs.begin(), key_value_pairs.end());</div></div><!-- fragment --><p> Results in the following [key, value]-pairs stored in the info object (not necessarily in this order): <br />
 <code>["key1", "value1_override"]</code>, <code>["key2", "value2"]</code> and <code>["key3", "value3"]</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>must meet the <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first [key, value]-pair in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator one-past the last [key, value]-pair in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> and <code>last</code> <b>must</b> refer to the same container. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> form a valid range, i.e. <code>first</code> must be less or equal than <code>last</code>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If any key or value exceed their size limit. <br />
 If <code>first</code> and <code>last</code> don't denote a valid range. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_create(MPI_Info *info);                                    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;last - first&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b0899a6845db4c6a0521fa548d61702"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the info object with the contents of the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>init</code>. </p>
<p>If multiple [key, value]-pairs in the range share the same key, the <b>last</b> occurrence determines the final value.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> obj = { {<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>},</div><div class="line">                     {<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>},</div><div class="line">                     {<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1_override&quot;</span>},</div><div class="line">                     {<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>} };</div></div><!-- fragment --><p> Results in the following [key, value]-pairs stored in the info object (not necessarily in this order):<br />
 <code>["key1", "value1_override"]</code>, <code>["key2", "value2"]</code> and <code>["key3", "value3"]</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> to initialize the [key, value]-pairs of the info object with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_create(MPI_Info *info);                                    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;init.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a566161e4d8a5547884d158f472214d7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::is_pair... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the info object with the contents of the parameter pack <code>args</code>. </p>
<p>If multiple [key, value]-pairs in the range share the same key, the <b>last</b> occurrence determines the final value.</p>
<p>Example: </p><div class="fragment"><div class="line">MPI_Info mpi_info;</div><div class="line"><span class="keyword">auto</span> p1 = std::make_pair(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div><div class="line">std::pair&lt;const std::string, std::string&gt; p2(<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> <a class="code" href="classmpicxx_1_1info.html#a674b9633f608f0965bd0bc39f7672356">info</a> (p1, p2, std::make_pair(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1_override&quot;</span>), std::make_pair(<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>));</div><div class="line"></div><div class="line">mpi_info = MPI_INFO_NULL;    <span class="comment">// &lt;- does not change the value of &#39;info&#39;!</span></div></div><!-- fragment --><p> Results in the following [key, value]-pairs stored in the info object (not necessarily in this order):<br />
 <code>["key1", "value1_override"]</code>, <code>["key2", "value2"]</code> and <code>["key3", "value3"]</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meed the <a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">mpicxx::detail::is_pair</a> requirements and must not be empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>an arbitrary number (but at least 1) of [key, value]-pairs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_create(MPI_Info *info);                                    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;sizeof...(T)&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="aca1396fd807a3349a2cc0baab57d5ff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mpicxx::info::info </td>
          <td>(</td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_freeable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap a <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object in an <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the raw <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_freeable</td><td>mark whether the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object wrapped in this info object should be automatically freed at the end of its lifetime</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The newly constructed info object is in a valid state iff <code>other</code> isn't <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If <code>is_freeable</code> is set to <code>false</code>, <b>the user</b> has to ensure that the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object <code>other</code> gets properly freed (via a call to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a>) at the end of its lifetime. </dd>
<dd>
Changing the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object <b>does not</b> change the value of <code>*this</code>!: <div class="fragment"><div class="line">MPI_Info mpi_info;</div><div class="line">MPI_Info_create(&amp;mpi_info);</div><div class="line"></div><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> <a class="code" href="classmpicxx_1_1info.html#a674b9633f608f0965bd0bc39f7672356">info</a> (mpi_info, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">mpi_info = MPI_INFO_NULL;    <span class="comment">// &lt;- does not change the value of &#39;info&#39;!</span></div></div><!-- fragment --> <dl class="section assert_sanity">
<dt>Sanity assertions</dt>
<dd>If <code>other</code> equals to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> <b>and</b> <code>is_freeable</code> is set to <code>true</code>. </dd>
</dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="af6c97e9dceb5e980bd6ed8571d245f18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpicxx::info::~info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the info object. </p>
<p>Calls <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a> if and only if the info object is marked freeable. Only objects created through <a class="el" href="classmpicxx_1_1info.html">mpicxx::info(MPI_Info, const bool)</a> can be marked as non-freeable (or info objects which are moved-from such objects). <br />
 For example <a class="el" href="classmpicxx_1_1info.html#a2cb40e9e8a8dc51504dd7a697986a28e">mpicxx::info::env</a> is <b>non-freeable</b> due to the fact that the MPI runtime system would crash if <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a> is called with <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>No attempt to automatically free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> <b>must</b> be made. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Invalidates <b>all</b> iterators referring to <code>*this</code>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If an attempt is made to free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_free(MPI_info *info);    <span class="comment">// at most once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac655696a9c371d9d6795f434b385252e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html">info</a>&amp; mpicxx::info::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<p>Retains <code>rhs's</code> [key, value]-pair ordering. Gracefully handles self-assignment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>another info object to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No attempt to automatically free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code> <b>must</b> be made. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The assigned to info object is in a valid state iff <code>other</code> is in a valid state. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Every copied info object (except if <code>other.get() == MPI_INFO_NULL</code>) is marked <b>freeable</b> independent of the <b>freeable</b> state of the copied-from info object.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If an attempt is made to free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code>. </dd>
</dl>
<dl class="section assert_sanity">
<dt>Sanity assertions</dt>
<dd>If <code>*this</code> and <code>rhs</code> are the same info object. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_free(MPI_info *info);                     <span class="comment">// at most once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_dup(MPI_info info, MPI_info *newinfo);    <span class="comment">// at most once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c172b3d18c1ff9ec673eb47a75e2fc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html">info</a>&amp; mpicxx::info::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with contents of <code>other</code> using move semantics. </p>
<p>Retains <code>rhs's</code> [key, value]-pair ordering. Does <b>not</b> handle self-assignment (as of <a href="https://isocpp.org/wiki/faq/assignment-operators">https://isocpp.org/wiki/faq/assignment-operators</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>another info object to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No attempt to automatically free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code> <b>must</b> be made. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rhs</code> is in the moved-from state, i.e. it refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All iterators referring to <code>rhs</code> remain valid, but now refer to <code>*this</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only a limited number of member functions can be called on an info object referring to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> (aka moved-from state):<ul>
<li>the destructor <a class="el" href="classmpicxx_1_1info.html#af6c97e9dceb5e980bd6ed8571d245f18" title="Destructs the info object. ">~info()</a></li>
<li>all assignment operators: <a class="el" href="classmpicxx_1_1info.html#ac655696a9c371d9d6795f434b385252e">mpicxx::info::operator=(const mpicxx::info&amp;)</a>, <a class="el" href="classmpicxx_1_1info.html#a0c172b3d18c1ff9ec673eb47a75e2fc7">mpicxx::info::operator=(mpicxx::info&amp;&amp;)</a> and <a class="el" href="classmpicxx_1_1info.html#ac0c3a7a92dad6af8d264609ed80e03cb">mpicxx::info::operator=(std::initializer_list&lt;value_type&gt;)</a></li>
<li>the swap member function: <a class="el" href="classmpicxx_1_1info.html#a1c1c276b1173ea4d51586922ce64df1c">mpicxx::info::swap(mpicxx::info&amp;)</a></li>
<li>the relational operators: <a class="el" href="classmpicxx_1_1info.html#a5c6d31526b4d271002d021f3e007843f">mpicxx::info::operator==(const mpicxx::info&amp;, const mpicxx::info&amp;)</a> and mpicxx::info::operator!=(const mpicxx::info&amp;, const mpicxx::info&amp;)</li>
<li>all static member functions: <a class="el" href="classmpicxx_1_1info.html#aad3f84c6c6a0a0287ed285a4c117632f">mpicxx::info::max_size()</a>, <a class="el" href="classmpicxx_1_1info.html#a0f933af2841504301c7016d930789d94">mpicxx::info::max_key_size()</a> and <a class="el" href="classmpicxx_1_1info.html#ab16ceb42130a329753d9d2fe328a795c">mpicxx::info::max_value_size()</a></li>
<li>all getters: <a class="el" href="classmpicxx_1_1info.html#acf529df856751661fd63439997712527">mpicxx::info::get()</a>, <a class="el" href="classmpicxx_1_1info.html#a32dd0ffdd2fff80d77e323bb1eb62f0f">mpicxx::info::get() const</a> and <a class="el" href="classmpicxx_1_1info.html#ab17e292ac2fc0f18b3766085d5279e41">mpicxx::info::freeable() const</a></li>
</ul>
</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If an attempt is made to free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code>. </dd>
</dl>
<dl class="section assert_sanity">
<dt>Sanity assertions</dt>
<dd><code>*this</code> and <code>rhs</code> are the same info object. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_free(MPI_info *info);    <span class="comment">// at most once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0c3a7a92dad6af8d264609ed80e03cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html">info</a>&amp; mpicxx::info::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code>. </p>
<p>If multiple [key, value]-pairs in the range share the same key, the <b>last</b> occurrence determines the final value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> to initialize the [key, value]-pairs of the info object with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No attempt to automatically free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code> <b>must</b> be made. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If an attempt is made to free <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_ENV</em></a> as <code>*this</code>. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_free(MPI_info *info);                                      <span class="comment">// at most once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_create(MPI_Info *info);                                    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;init.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a5618b588d5175c53a74249f00f0bc192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> mpicxx::info::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the first [key, value]-pair of the info object. </p>
<p>If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d17488a6a2173429df46897a2005f8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> mpicxx::info::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the element following the last [key, value]-pair of the info object. </p>
<p>This element acts as a placeholder; attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">mpicxx::info::iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d4fed28987b0bc4c70011ac235d882f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> mpicxx::info::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair of the info object. </p>
<p>If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#afd7a9db3da917ca964c98caa3dd195e3">mpicxx::info::cend()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e79e2ca1b10707af1e192424ea8cd87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> mpicxx::info::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair of the info object. </p>
<p>This element acts as a placeholder; attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="affe02eb6b8a22e7c7952e54671f4dd4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> mpicxx::info::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair of the info object. </p>
<p>If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#afd7a9db3da917ca964c98caa3dd195e3">mpicxx::info::cend()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd7a9db3da917ca964c98caa3dd195e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> mpicxx::info::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair of the info object. </p>
<p>This element acts as a placeholder; attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">mpicxx::info::const_iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6760609ddf99ff1f04614e011bf4df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">reverse_iterator</a> mpicxx::info::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the first [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the last [key, value]-pair of the non-reversed info object. If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#a41cbd7bb270347d67cdebd4d55cea5f2">mpicxx::info::rend()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41cbd7bb270347d67cdebd4d55cea5f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">reverse_iterator</a> mpicxx::info::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the element preceding the first [key, value]-pair of the non-reversed info object. This element acts as a placeholder, attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#a254ece09352f3981826a299a04079ed1">mpicxx::info::reverse_iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2090404400cc115b0adb836c8b3f07eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a> mpicxx::info::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the last [key, value]-pair of the non-reversed info object. If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#a210b4486bd8e67fb6b868d26d39bc38b">mpicxx::info::crend()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba241adf983bdde1ebcfaa96a70f78d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a> mpicxx::info::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the element preceding the first [key, value]-pair of the non-reversed info object. This element acts as a placeholder, attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0d995ab22661e388de263711d3d38f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a> mpicxx::info::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the last [key, value]-pair of the non-reversed info object. If the info object is empty, the returned <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> will be equal to <a class="el" href="classmpicxx_1_1info.html#a210b4486bd8e67fb6b868d26d39bc38b">mpicxx::info::crend()</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the first [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info *info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --> For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a210b4486bd8e67fb6b868d26d39bc38b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">const_reverse_iterator</a> mpicxx::info::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair of the reversed info object. </p>
<p>It corresponds to the element preceding the first [key, value]-pair of the non-reversed info object. This element acts as a placeholder, attempting to access it results in <b>undefined behavior</b>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmpicxx_1_1info.html#acb3f8016e01aab7d3de0b99bf6deeaf6">mpicxx::info::const_reverse_iterator</a> to the element following the last [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using an iterator see the <a class="el" href="classmpicxx_1_1info_1_1iterator__impl.html">mpicxx::info::iterator_impl</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58daa3b8eb5c9934742797d09ce601de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpicxx::info::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the info object has no [key, value]-pairs, i.e. whether <code><a class="el" href="classmpicxx_1_1info.html#a5618b588d5175c53a74249f00f0bc192" title="Returns an mpicxx::info::iterator to the first [key, value]-pair of the info object. ">begin()</a> == <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d" title="Returns an mpicxx::info::iterator to the element following the last [key, value]-pair of the info obj...">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the info object is empty, <code>false</code> otherwise <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a66c0052f50d435a94e639548e134e7c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of [key, value]-pairs in the info object, i.e. <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(begin(), end())</code></a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of [key, value]-pairs in the info object <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);    <span class="comment">// exactly once </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="aad3f84c6c6a0a0287ed285a4c117632f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of [key, value]-pairs an info object is able to hold due to system or library implementation limitations, <br />
 i.e. <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(begin(), end())</code></a> for the largest info object. </p>
<dl class="section return"><dt>Returns</dt><dd>maximum number of [key, value]-pairs <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This value typically reflects the theoretical limit on the size of the info object, at most <a href="https://en.cppreference.com/w/cpp/types/numeric_limits"><code>std::numeric_limits&lt;difference_type&gt;::max()</code></a>. At runtime, the size of the info object may be limited to a value smaller than <a class="el" href="classmpicxx_1_1info.html#aad3f84c6c6a0a0287ed285a4c117632f">mpicxx::info::max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7798c2d24be1ab8a3ef6eb4183234e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::is_string T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info_1_1proxy.html">proxy</a> mpicxx::info::at </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value associated with the given <code>key</code> including bounds checks. </p>
<p>Returns a proxy class, which is used to distinguish between read and write accesses.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> obj = { {<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>} };</div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>) = <span class="stringliteral">&quot;bar&quot;</span>;                   <span class="comment">// write access</span></div><div class="line">    std::string str_val = obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>);     <span class="comment">// read access: returns a proxy object, which is immediately casted to a std::string</span></div><div class="line">    str_val = <span class="stringliteral">&quot;baz&quot;</span>;                         <span class="comment">// changing str_val will (obviously) not change the value of obj.at(&quot;key&quot;)</span></div><div class="line"></div><div class="line">    <span class="comment">// same as: obj.at(&quot;key&quot;) = &quot;baz&quot;;</span></div><div class="line">    <span class="keyword">auto</span> val = obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>);                <span class="comment">// read access: returns a proxy object</span></div><div class="line">    val = <span class="stringliteral">&quot;baz&quot;</span>;                             <span class="comment">// write access: now obj.at(&quot;key&quot;) will return &quot;baz&quot;</span></div><div class="line"></div><div class="line">    obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key_2&quot;</span>) = <span class="stringliteral">&quot;baz&quot;</span>;                 <span class="comment">// will throw</span></div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; e) {</div><div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;      <span class="comment">// prints: &quot;key_2 doesn&#39;t exist!&quot;</span></div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">must</td><td>meet the <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">mpicxx::detail::is_string</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the <code>key</code> of the [key, value]-pair to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a proxy object</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The <code>key</code> <b>must</b> already exist, otherwise a <a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a> exception will be thrown.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the info object does not have a [key, value]-pair with the specified <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly once</span></div></div><!-- fragment --> For <em>MPI</em> functions called while using a proxy see the <a class="el" href="classmpicxx_1_1info_1_1proxy.html">mpicxx::info::proxy</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a898ab9a9f313dec15a1e137078fd83b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpicxx::info::at </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value associated with the given <code>key</code> including bounds checks. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> obj = { {<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>} };</div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>) = <span class="stringliteral">&quot;bar&quot;</span>;                      <span class="comment">// write access: modifying a temporary is nonsensical</span></div><div class="line">    std::string str_val = obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>);        <span class="comment">// read access: directly returns a std::string</span></div><div class="line">    str_val = <span class="stringliteral">&quot;baz&quot;</span>;                            <span class="comment">// changing str_val will (obviously) not change the value of obj.at(&quot;key&quot;)</span></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> val = obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key&quot;</span>);                   <span class="comment">// read access: directly returns a std::string</span></div><div class="line">    val = <span class="stringliteral">&quot;baz&quot;</span>;                                <span class="comment">// typeof val is std::string -&gt; changing val will not change the value of obj.at(&quot;key)&quot;</span></div><div class="line"></div><div class="line">    std::string throw_val = obj.<a class="code" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1">at</a>(<span class="stringliteral">&quot;key_2&quot;</span>);    <span class="comment">// will throw</span></div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; e) {</div><div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;         <span class="comment">// prints: &quot;key_2 doesn&#39;t exist!&quot;</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the <code>key</code> of the [key, value]-pair to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value associated with <code>key</code> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The <code>key</code> <b>must</b> already exist, otherwise a <a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a> exception will be thrown. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This const overload does <b>not</b> return a proxy object but a <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>!</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the info object does not have a [key, value]-pair with the specified <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// at most once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="add2673e15b1de1fa4506775cce1493f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::is_string T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info_1_1proxy.html">proxy</a> mpicxx::info::operator[] </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value associated with the given <code>key</code>. </p>
<p>Returns a proxy class which is used to distinguish between read and write access. <br />
 <code>mpicxx::info::operator[]</code> is non-const because it inserts the <code>key</code> if it doesn't exist. If this behavior is undesirable or if the container is const, <code><a class="el" href="classmpicxx_1_1info.html#ac7798c2d24be1ab8a3ef6eb4183234e1" title="Access the value associated with the given key including bounds checks. ">mpicxx::info::at()</a></code> may be used.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classmpicxx_1_1info.html">mpicxx::info</a> obj = { {<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>} };</div><div class="line"></div><div class="line">obj[<span class="stringliteral">&quot;key&quot;</span>] = <span class="stringliteral">&quot;bar&quot;</span>;                 <span class="comment">// write access</span></div><div class="line">std::string str_val = obj[<span class="stringliteral">&quot;key&quot;</span>];   <span class="comment">// read access: returns a proxy object, which is immediately casted to a std::string</span></div><div class="line">str_val = <span class="stringliteral">&quot;baz&quot;</span>;                    <span class="comment">// changing val won&#39;t alter obj[&quot;key&quot;] !!!</span></div><div class="line"></div><div class="line"><span class="comment">// same as: obj[&quot;key&quot;] = &quot;baz&quot;;</span></div><div class="line"><span class="keyword">auto</span> val = obj[<span class="stringliteral">&quot;key&quot;</span>];              <span class="comment">// read access: returns a proxy object</span></div><div class="line">val = <span class="stringliteral">&quot;baz&quot;</span>;                        <span class="comment">// write access: now obj[&quot;key&quot;] will return &quot;baz&quot;</span></div><div class="line"></div><div class="line">obj[<span class="stringliteral">&quot;key_2&quot;</span>] = <span class="stringliteral">&quot;baz&quot;</span>;               <span class="comment">// inserts a new [key, value]-pair in obj</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meet the <a class="el" href="namespacempicxx_1_1detail.html#ac868ceb9222d55ab6a6cdfd549811837">mpicxx::detail::is_string</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the <code>key</code> of the [key, value]-pair to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a proxy object</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>may not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd>For <em>MPI</em> functions called while using a proxy see the <a class="el" href="classmpicxx_1_1info_1_1proxy.html">mpicxx::info::proxy</a> documentation. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ff62267cd204ac64ecda16907ebad22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, bool&gt; mpicxx::info::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given [key, value]-pair if the info object doesn't already contain a [key, value]-pair with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> of the [<b>key</b>, value]-pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><code>value</code> of the [key, <b>value</b>]-pair to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted [key, value]-pair (or the one that prevented the insertion) and a <code>bool</code> denoting whether the insertion took place</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<b>Both</b> <code>key</code> <b>and</b> <code>value</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The <code>value's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place (i.e. the returned <code>bool</code> is <code>true</code>). <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> or <code>value</code> exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);                    <span class="comment">// at most once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                                      <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                               <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f2b444bb7b94d0f54c7c4d02c1e2df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::input_iterator InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all [key, value]-pairs from the range [<code>first</code>, <code>last</code>) if the info object does not already contain a [key, value]-pair with an equivalent key. </p>
<p>If multiple [key, value]-pairs in the range have the same key, the <b>first</b> occurrence determines the final value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>must meet the <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first [key, value]-pair in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator one-past the last [key, value]-pair in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> refer to the same container. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> form a valid range, i.e. <code>first</code> must be less or equal than <code>last</code>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>first</code> and <code>last</code> don't denote a valid range. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly &#39;last - first&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);                    <span class="comment">// at most &#39;last - first&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4436a93cbef1a6a01e0633b241082b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all [key, value]-pairs from the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code> if the info object does not already contain a [key, value]-pair with an equivalent key. </p>
<p>If multiple [key, value]-pairs in the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> have the same key, the <b>first</b> occurrence determines the final value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> to insert the [key, value]-pairs from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                      <span class="comment">// exactly &#39;ilist.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// at most &#39;ilist.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ab56346eb5afbe39c50b302372884e1e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::is_pair... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all [key, value]-pairs from the parameter pack <code>args</code> if the info object does not already contain a [key, value]-pair with an equivalent key. </p>
<p>If multiple [key, value]-pairs in the parameter pack have the same key, the <b>first</b> occurrence determines the final value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meed the <a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">mpicxx::detail::is_pair</a> requirements and must not be empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>an arbitrary number (but at least 1) of [key, value]-pairs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                      <span class="comment">// exactly &#39;sizeof...(T)&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// at most &#39;sizeof...(T)&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a3717b821521beeb4b9bec2003de080b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, bool&gt; mpicxx::info::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or assign the given [key, value]-pair to the info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> of the [<b>key</b>, value]-pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><code>value</code> of the [key, <b>value</b>]-pair to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted or assigned [key, value]-pair and a <code>bool</code> denoting whether the insertion (<code>true</code>) or the assignment (<code>false</code>) took place</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<b>Both</b> <code>key</code> <b>and</b> <code>value</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The <code>value's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place (i.e. the returned <code>bool</code> is <code>true</code>). <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> or <code>value</code> exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);                    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                                      <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                               <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2c4c14429bea8bc034fed7ab1c7128a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::input_iterator InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts or assigns [key, value]-pairs from range [<code>first</code>, <code>last</code>) to the info object. </p>
<p>If multiple [key, value]-pairs in the range have the same key, the <b>last</b> occurrence determines the final value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>must meet the <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a> requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first [key, value]-pair in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator one-past the last [key, value]-pair in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> refer to the same container. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> form a valid range, i.e. <code>first</code> must be less or equal than <code>last</code>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>first</code> and <code>last</code> don't denote a valid range. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;last - first&#39; times </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bf832a5749c4664b5e55a239544eccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts or assigns [key, value]-pairs from the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> <code>ilist</code> to the info object. </p>
<p>If multiple [key, value]-pairs in the <a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> have the same key, the <b>last</b> occurrence determines the final value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> to insert or assign the [key, value]-pairs from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;ilist.size()&#39; times </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a2839a18169b2445288146e0e89c20f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::is_pair... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts or assigns [key, value]-pairs from the parameter pack <code>args</code> to the info object. </p>
<p>If multiple [key, value]-pairs in the parameter pack have the same key, the <b>last</b> occurrence determines the final value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must meed the <a class="el" href="namespacempicxx_1_1detail.html#aa6fa2de298220e8cb4c28699796c5563">mpicxx::detail::is_pair</a> requirements and must not be empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>an arbitrary number (but at least 1) of [key, value]-pairs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
All <code>keys</code> and <code>values</code> <b>must</b> include the null-terminator. </dd>
<dd>
The length of <b>any</b> key <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd>
<dd>
The length of <b>any</b> value <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an insertion took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first insertion point remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If any key or value exceed their size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);    <span class="comment">// exactly &#39;sizeof...(T)&#39; times </span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a90c651d9b6fb1b923efc8118a625a3d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all [key, value]-pairs from the info object. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The info object is empty, i.e. <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9" title="Returns the number of [key, value]-pairs in the info object, i.e. std::distance(begin(), end()). ">size()</a> == 0</code> respectively <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a58daa3b8eb5c9934742797d09ce601de" title="Checks if the info object has no [key, value]-pairs, i.e. whether begin() == end(). ">empty()</a> == true</code>. </dd>
<dd>
Invalidates <b>all</b> iterators referring to <code>*this</code>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);         <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a5837d0f81c7dfba8a434209f69630dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> mpicxx::info::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the [key, value]-pair at <code>pos</code>. </p>
<p>The iterator <code>pos</code> must be valid and <b>dereferenceable</b>. Thus the <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the [key, value]-pair to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the removed [key, value]-pair (= position of <code>pos</code> prior to removal); <br />
 if <code>pos</code> refers to the last [key, value]-pair, then the <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a> iterator is returned</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>pos</code> <b>must</b> refer to <code>*this</code> info object. </dd>
<dd>
The position denoted by <code>pos</code> <b>must</b> be in the half-open interval [0, <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9" title="Returns the number of [key, value]-pairs in the info object, i.e. std::distance(begin(), end()). ">size()</a></code>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the point of erase remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>pos</code> does not refer to <code>*this</code> info object. <br />
 If attempting an illegal dereferencing. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);         <span class="comment">// exactly once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5d9b5c7cfde4bfbce27f64c6c3486cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> mpicxx::info::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all [key, value]-pairs in the range [<code>first</code>, <code>last</code>). </p>
<p>[<code>first</code>, <code>last</code>) must be a valid range in <code>*this</code>. The iterator <code>first</code> does not need to be dereferenceable if <code>first == last</code>: erasing an empty range is a no-op.</p>
<p>The <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> only guarantees that the number of a given key does not change <b>as long as</b> no call to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_set</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_delete</em></a> is made.</p>
<p>Therefore (to be compliant with the standard) this function performs two steps:</p><ol type="1">
<li>Save all keys of the [key, value]-pairs contained in [<code>first</code>, <code>last</code>) in a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector&lt;std::string&gt;&gt;</code></a>.</li>
<li>Delete all [key, value]-pairs in the info object <code>c</code> with a key contained in the previously created vector. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first [key, value]-pair in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator one-past the last [key, value]-pair in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed [key, value]-pair (= position of <code>first</code> prior to any removal); <br />
 if <code>last == <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d" title="Returns an mpicxx::info::iterator to the element following the last [key, value]-pair of the info obj...">end()</a></code> prior to removal, then the updated <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a> iterator is returned; <br />
 if [<code>first</code>, <code>last</code>) is an empty range, then <code>last</code> is returned</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>may not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>first</code> and <code>last</code> <b>must</b> refer to <code>*this</code> info object </dd>
<dd>
The position denoted by <code>first</code> <b>must</b> be in the interval [0, <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9" title="Returns the number of [key, value]-pairs in the info object, i.e. std::distance(begin(), end()). ">size()</a></code>]. </dd>
<dd>
The position denoted by <code>last</code> <b>must</b> be in the interval [0, <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9" title="Returns the number of [key, value]-pairs in the info object, i.e. std::distance(begin(), end()). ">size()</a></code>]. </dd>
<dd>
<code>first</code> <b>must</b> be less or equal than <code>last</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first point of erase remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>first</code> or <code>last</code> does not refer to <code>*this</code> info object. <br />
 If attempting an illegal dereferencing. </dd>
</dl>
<dl class="section assert_sanity">
<dt>Sanity assertions</dt>
<dd>If <code>first</code> is greater than <code>last</code>. </dd>
</dl>
</li>
</ol>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// exactly &#39;last - first&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);         <span class="comment">// exactly &#39;last - first&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a80a6a53da50db9d617e69221958aff96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::erase </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the [key, value]-pair (if one exists) with the key equivalent to <code>key</code>. </p>
<p>Returns either 1 (key found and removed) or 0 (no such key found and therefore nothing removed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the [key, value]-pair to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements removed (either 0 or 1)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an erasure took place (i.e. the returned <code>size_type</code> is 1). <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the point of erase remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);                                    <span class="comment">// at most once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c1c276b1173ea4d51586922ce64df1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the info object with those of <code>other</code>. </p>
<p>Does not invoke any move, copy, or swap operations on individual [key, value]-pairs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>info object to exchange the contents with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>*this</code> is in a valid state iff <code>other</code> was in a valid state and vice versa. </dd>
<dd>
All iterators remain valid, but now refer to the other info object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4d7dcd1a1c88b23a69172c7c19b6cec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a> mpicxx::info::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the [key, value]-pair at <code>pos</code> and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the [key, value]-pair to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extracted [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>pos</code> <b>must</b> refer to <code>*this</code> info object. </dd>
<dd>
The position denoted by <code>pos</code> <b>must</b> be in the half-open interval [0, <code>this-&gt;<a class="el" href="classmpicxx_1_1info.html#a66c0052f50d435a94e639548e134e7c9" title="Returns the number of [key, value]-pairs in the info object, i.e. std::distance(begin(), end()). ">size()</a></code>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the point of extraction remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>pos</code> does not refer to <code>*this</code> info object. <br />
 If attempting an illegal dereferencing. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                                  <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);                                       <span class="comment">// exactly once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a69594c2c6b82aceb39323149e8975e9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classmpicxx_1_1info.html#a14dde098f7e38710ea9ec945b379adf9">value_type</a>&gt; mpicxx::info::extract </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the [key, value]-pair (if one exists) with the key equivalent to <code>key</code> and returns the removed [key, value]-pair. </p>
<p>Returns a <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> holding the removed [key, value]-pair if the <code>key</code> exists, <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><code>std::nullopt</code></a> otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the <code>key</code> to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extracted [key, value]-pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> are invalidated, if an extraction took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the point of extraction remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// at most once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);                                       <span class="comment">// at most once</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d0f5caa340db4c52ef9b913eb5246da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpicxx::info::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract each [key, value]-pair in <code>source</code> and insert it into <code>*this</code>. </p>
<p>If there is a [key, value]-pair in <code>*this</code> with key equivalent to an [key, value]-pair from <code>source</code>, than the [key, value]-pair is not extracted from <code>source</code>.</p>
<p>Directly returns if a "self-extraction" is attempted.</p>
<p>The <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> only guarantees that the number of a given key does not change <b>as long as</b> no call to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_set</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_delete</em></a> is made.</p>
<p>Therefore (to be compliant with the standard) this function performs two steps:</p><ol type="1">
<li>Save all keys of the [key, value]-pairs that will be extracted in a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector&lt;std::string&gt;&gt;</code></a>. Add the respective [key, value]-pairs to <code>*this</code>.</li>
<li>Delete all [key, value]-pairs in <code>source</code> with a key contained in the previously created vector. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>the info object to transfer the [key, value]-pairs from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>source</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>*this</code> and <code>source</code> are invalidated, if a transfer of [key, value]-pairs took place. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first point of insertion/extraction remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> or <code>source</code> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section assert_sanity">
<dt>Sanity assertions</dt>
<dd>If <code>*this</code> and <code>source</code> are the same info object. </dd>
</dl>
</li>
</ol>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                                         <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// at least &#39;source.size()&#39; times, at most &#39;2 * source.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// at most &#39;source.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);                                       <span class="comment">// at most &#39;source.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_set(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value);                       <span class="comment">// at most &#39;source.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="af70ad2cab67e4691f7953a49bb2d31b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::count </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of [key, value]-pairs with key equivalent to <code>key</code>. </p>
<p>Since info objects don't allow duplicated keys the returned value is either 0 (key not found) or 1 (key found).</p>
<p>Therefore <a class="el" href="classmpicxx_1_1info.html#a063ced9374c9b852eb12b04b9bac69bf">contains(const std::string_view) const</a> may be a better choice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pairs to count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of [key, value]-pairs with key equivalent to <code>key</code>, which is either 0 or 1 <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d9b4dca42989c5a9398e0de14735ec4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a> mpicxx::info::find </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a [key, value]-pair with key equivalent to <code>key</code>. </p>
<p>If the key is found, returns an iterator pointing to the corresponding [key, value]-pair, otherwise the past-the-end iterator is returned (see <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pair to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to a [key, value]-pair with key equivalent to <code>key</code> or the past-the-end iterator if no such key is found <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a9429cd04a5c3cc3383255095821baccd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a> mpicxx::info::find </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a [key, value]-pair with key equivalent to <code>key</code>. </p>
<p>If the key is found, returns a const_iterator pointing to the corresponding [key, value]-pair, otherwise the past-the-end const_iterator is returned (see <a class="el" href="classmpicxx_1_1info.html#afd7a9db3da917ca964c98caa3dd195e3">mpicxx::info::cend()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pair to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to a [key, value]-pair with key equivalent to <code>key</code> or the past-the-end iterator if no such key is found <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a063ced9374c9b852eb12b04b9bac69bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpicxx::info::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is a [key, value]-pair with key equivalent to <code>key</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pair to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is such a [key, value]-pair, otherwise <code>false</code> <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e6ec98bc2092e420e45a9677e859faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>, <a class="el" href="classmpicxx_1_1info.html#a4abee20786bc8a05ae24f68048a5b150">iterator</a>&gt; mpicxx::info::equal_range </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all [key, value]-pairs with key equivalent to <code>key</code>. </p>
<p>The range is defined by two iterators, the first pointing to the first [key, value]-pair of the wanted range and the second pointing past the last [key, value]-pair of the range.</p>
<p>Since info objects don't allow duplicated keys <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(it_range.first, it_range.second)</code></a> is either 0 (key not found) or 1 (key found).</p>
<p>Therefore <a class="el" href="classmpicxx_1_1info.html#a9d9b4dca42989c5a9398e0de14735ec4">mpicxx::info::find(const std::string_view)</a> may be a better choice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pair to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> containing a pair of iterators defining the wanted range;<br />
 if there is no such element, past-the-end (see <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a>) iterators are returned as both elements of the pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="afa10599c33db63a356dfa82ff6ad628b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>, <a class="el" href="classmpicxx_1_1info.html#abe8f0ff12d58a477eb8d64ffad72c70b">const_iterator</a>&gt; mpicxx::info::equal_range </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all [key, value]-pairs with key equivalent to <code>key</code>. </p>
<p>The range is defined by two const_iterators, the first pointing to the first [key, value]-pair of the wanted range and the second pointing past the last [key, value]-pair of the range.</p>
<p>Since info objects don't allow duplicated keys <a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance(const_it_range.first, const_it_range.second)</code></a> is either 0 (key not found) or 1 (key found).</p>
<p>Therefore <a class="el" href="classmpicxx_1_1info.html#a9429cd04a5c3cc3383255095821baccd">mpicxx::info::find(const std::string_view) const</a> may be a better choice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td><code>key</code> value of the [key, value]-pair to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> containing a pair of const_iterators defining the wanted range; <br />
 if there is no such element, past-the-end (see <a class="el" href="classmpicxx_1_1info.html#a8d17488a6a2173429df46897a2005f8d">mpicxx::info::end()</a>) const_iterators are returned as both elements of the pair <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
<dd>
<code>key</code> <b>must</b> include the null-terminator. </dd>
<dd>
The <code>key's</code> length <b>must</b> be greater than 0 and less than <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. <br />
 If <code>key</code> exceeds its size limit. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// at most &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a329a23981fb8b3b65ab50db4f93ac9f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmpicxx_1_1info.html#a7f718f1397b8e80181a75d4a39baac25">key_type</a>&gt; mpicxx::info::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> containing all keys of the info object. </p>
<dl class="section return"><dt>Returns</dt><dd>all keys of the info object <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);           <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);    <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="aec497f4b47fb1f40fb3a14068ce394f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmpicxx_1_1info.html#a22a86fb5242a07f81b96d50d5c7324c1">mapped_type</a>&gt; mpicxx::info::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> containing all values of the info object. </p>
<dl class="section return"><dt>Returns</dt><dd>all values of the info object <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>*this</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                                         <span class="comment">// exactly once</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                                  <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly &#39;this-&gt;size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f933af2841504301c7016d930789d94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::max_key_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible key size of any [key, value]-pair. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum key size (= <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_KEY</em></a>) <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="ab16ceb42130a329753d9d2fe328a795c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmpicxx_1_1info.html#acbf4543ace2800d0d270e0211df9f06a">size_type</a> mpicxx::info::max_value_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible value size of any [key, value]-pair. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum value size (= <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_MAX_INFO_VAL</em></a>) <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a32dd0ffdd2fff80d77e323bb1eb62f0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MPI_Info&amp; mpicxx::info::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object wrapped in this <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> object <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="acf529df856751661fd63439997712527"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Info&amp; mpicxx::info::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object wrapped in this <a class="el" href="classmpicxx_1_1info.html">mpicxx::info</a> object <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<a class="anchor" id="ab17e292ac2fc0f18b3766085d5279e41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpicxx::info::freeable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the underlying <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info</em></a> object gets automatically freed upon destruction, i.e. the destructor calls <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a> gets called upon destruction, <code>false</code> otherwise <span class="label label-info nodiscard">nodiscard</span> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a5c6d31526b4d271002d021f3e007843f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of the two info objects for equality. </p>
<p>Two info objects compare equal iff they have the same size and their contents compare equal. <br />
 Automatically generates <code>mpicxx::info::operator!=(const info&amp;, const info&amp;)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the <code>lhs</code> info object to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the <code>rhs</code> info object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of the info objects are equal, <code>false</code> otherwise <span class="label label-info nodiscard">nodiscard</span></dd></dl>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nkeys(MPI_Info info, <span class="keywordtype">int</span> *nkeys);                                         <span class="comment">// at most twice</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                                  <span class="comment">// at most &#39;lhs.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// at most &#39;2 * lhs.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// at most &#39;2 * lhs.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<a class="anchor" id="ada89b6e5e37c6af42c7ac81e0e460342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a href="https://en.cppreference.com/w/cpp/algorithm/swap"><code>std::swap</code></a> algorithm for info objects. Swaps the contents of <code>lhs</code> and <code>rhs</code>. </p>
<p>Calls <code>lhs.swap(rhs)</code>. </p><pre class="fragment">     Does not invoke any move, copy or swap operations on individual elements.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>the info object whose contents to swap </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>the info object whose contents to swap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>All iterators remain valid, but now refer to the other info object. </dd></dl>

</div>
</div>
<a class="anchor" id="a3857914e43179bf1e654071777d23fb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpicxx_1_1info.html">info</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all [key, value]-pairs that satisfy the predicate <code>pred</code> from the info object. </p>
<p>The <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> only guarantees that the number of a given key does not change <b>as long as</b> no call to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_set</em></a> or <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_delete</em></a> is made.</p>
<p>Therefore (to be compliant with the standard) this function performs two steps:</p><ol type="1">
<li>Save all keys, for which the corresponding [key, value]-pair satisfies the predicate <code>pred</code>, in a <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector&lt;std::string&gt;&gt;</code></a>.</li>
<li>Delete all [key, value]-pairs in the info object <code>c</code> with a key contained in the previously created vector. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pred</td><td>a valid predicate which accepts a <code>value_type</code> and returns a <code>bool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>info object from which to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate that returns <code>true</code> if the element should be erased</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>c</code> <b>must not</b> refer to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> all iterators referring to <code>c</code> are invalidated. <br />
 Specific MPI implementations <b>may</b> differ in this regard, i.e. iterators before the first point of erase remain valid, all other iterators are invalidated.</dd></dl>
<dl class="section assert_precondition">
<dt>Precondition assertions</dt>
<dd>If <code>c</code> refers to <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_INFO_NULL</em></a>. </dd>
</dl>
</li>
</ol>
<dl class="section calls">
<dt>MPI functions internally called</dt>
<dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> MPI_Info_get_nthkey(MPI_Info info, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *key);                                  <span class="comment">// exactly &#39;c.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get_valuelen(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> *valuelen, <span class="keywordtype">int</span> *flag);       <span class="comment">// exactly &#39;c.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_get(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> valuelen, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> *flag);    <span class="comment">// exactly &#39;c.size()&#39; times</span></div><div class="line"><span class="keywordtype">int</span> MPI_Info_delete(MPI_Info info, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);                                       <span class="comment">// at most &#39;c.size()&#39; times</span></div></div><!-- fragment --></dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2cb40e9e8a8dc51504dd7a697986a28e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmpicxx_1_1info.html">info</a> mpicxx::info::env = <a class="el" href="classmpicxx_1_1info.html">info</a>(MPI_INFO_ENV, false)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static member that holds all execution environment information defined in <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node225.htm"><em>MPI_INFO_ENV</em></a>. </p>
<p>As of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI standard 3.1</a> predefined keys of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node225.htm"><em>MPI_INFO_ENV</em></a> are: </p><table class="doxtable">
<tr>
<th align="left">key </th><th align="left">description  </th></tr>
<tr>
<td align="left">command </td><td align="left">name of program executed </td></tr>
<tr>
<td align="left">argv </td><td align="left">space separated arguments to command </td></tr>
<tr>
<td align="left">maxprocs </td><td align="left">maximum number of MPI processes to start (e.g. <code>"1024"</code>) </td></tr>
<tr>
<td align="left">soft </td><td align="left">allowed values for number of processors </td></tr>
<tr>
<td align="left">host </td><td align="left">hostname </td></tr>
<tr>
<td align="left">arch </td><td align="left">architecture name </td></tr>
<tr>
<td align="left">wdir </td><td align="left">working directory of the MPI process </td></tr>
<tr>
<td align="left">file </td><td align="left">value is the name of a file in which additional information is specified </td></tr>
<tr>
<td align="left">thread_level </td><td align="left">requested level of thread support, if requested before the program started execution (e.g. <code>"MPI_THREAD_SINGLE"</code>) </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The contents of <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node225.htm"><em>MPI_INFO_ENV</em></a> are implementation defined, i.e. not all of the predefined keys have to be defined.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd><b>No</b> <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a> gets called upon destruction (doing so would result in a MPI runtime failure). </dd></dl>

</div>
</div>
<a class="anchor" id="acb4a6623a8c390bc24a79f4d63ba7b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmpicxx_1_1info.html">info</a> mpicxx::info::null = <a class="el" href="classmpicxx_1_1info.html">info</a>(MPI_INFO_NULL, false)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static null object which is mainly used to explicitly indicate that <b>no</b> info is provided. </p>
<dl class="section attention"><dt>Attention</dt><dd><b>No</b> <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report/node229.htm"><em>MPI_Info_free</em></a> gets called upon destruction (doing so would result in a MPI runtime failure). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
</div>
<address class="footer">
  <div class="footer-container" style="color: #fff; font-size: 16px;">
    <span>Authored by Marcel Breyer</span>
    <a style="color: white; margin: 0 15%; text-decoration: none;" href="https://github.com/arkantos493/MPICXX">
      <i class="fa fa-github"><span style="font: 400 16px Roboto,sans-serif;"> GitHub</span></i>
    </a>
    <span class="theme-switch-wrapper">
      <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <span class="slider round"></span>
      </label>
      <em class="theme-switch-text">Enable Dark Mode!</em>
    </span>
  </div>
</address>
</div>
</body>
</html>
